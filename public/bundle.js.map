{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///./node_modules/.pnpm/applymixins@1.1.0/node_modules/applymixins/index.js","webpack:///./node_modules/.pnpm/buffer-compare@1.1.1/node_modules/buffer-compare/index.js","webpack:///./node_modules/.pnpm/event-iterator@2.0.0/node_modules/event-iterator/lib/dom.js","webpack:///./node_modules/.pnpm/event-iterator@2.0.0/node_modules/event-iterator/lib/event-iterator.js","webpack:///./node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","webpack:///./node_modules/.pnpm/get-iterator@1.0.2/node_modules/get-iterator/index.js","webpack:///./node_modules/.pnpm/it-keepalive@1.2.0/node_modules/it-keepalive/index.js","webpack:///./node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js","webpack:///./node_modules/.pnpm/mnemonist@0.39.5/node_modules/mnemonist/default-map.js","webpack:///./node_modules/.pnpm/mnemonist@0.39.5/node_modules/mnemonist/default-weak-map.js","webpack:///./node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js","webpack:///./node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js","webpack:///./node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js","webpack:///webpack/bootstrap","webpack:///./node_modules/.pnpm/tslib@2.5.3/node_modules/tslib/tslib.es6.mjs","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/string_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/buffer_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@tlv.tgz/node_modules/@ndn/tlv/lib/nni_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@tlv.tgz/node_modules/@ndn/tlv/lib/decoder_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/mod_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@tlv.tgz/node_modules/@ndn/tlv/lib/encoder_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/an_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/name/component_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/name/name_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/key-map_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/name/name-map_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@tlv.tgz/node_modules/@ndn/tlv/lib/string_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@tlv.tgz/node_modules/@ndn/tlv/lib/ev-decoder_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/platform_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/crypto_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/fwhint_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/impl-public-fields_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/name/digest-comp_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/key-locator_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@tlv.tgz/node_modules/@ndn/tlv/lib/extensible_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/sig-info_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/security/signing_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/interest_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/data_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/nack_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/iter_browser.js","webpack:///./node_modules/.pnpm/it-pushable@3.1.3/node_modules/it-pushable/dist/src/fifo.js","webpack:///./node_modules/.pnpm/it-pushable@3.1.3/node_modules/it-pushable/dist/src/index.js","webpack:///./node_modules/.pnpm/streaming-iterables@7.1.0/node_modules/streaming-iterables/dist/index.mjs","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@fw.tgz/node_modules/@ndn/fw/lib/face_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@fw.tgz/node_modules/@ndn/fw/lib/fib_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/name/algo_browser.js","webpack:///./node_modules/.pnpm/hirestime@7.0.3/node_modules/hirestime/dist/index.esm.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@fw.tgz/node_modules/@ndn/fw/lib/packet_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@fw.tgz/node_modules/@ndn/fw/lib/pit_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@fw.tgz/node_modules/@ndn/fw/lib/readvertise_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@fw.tgz/node_modules/@ndn/fw/lib/forwarder_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@endpoint.tgz/node_modules/@ndn/endpoint/lib/retx_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@util.tgz/node_modules/@ndn/util/lib/timer_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@endpoint.tgz/node_modules/@ndn/endpoint/lib/endpoint_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@endpoint.tgz/node_modules/@ndn/endpoint/lib/consumer_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@endpoint.tgz/node_modules/@ndn/endpoint/lib/producer_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@packet.tgz/node_modules/@ndn/packet/lib/name/alt-uri_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@l3face.tgz/node_modules/@ndn/l3face/lib/transport_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@lp.tgz/node_modules/@ndn/lp/lib/an_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@lp.tgz/node_modules/@ndn/lp/lib/packet_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@lp.tgz/node_modules/@ndn/lp/lib/fragmenter_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@lp.tgz/node_modules/@ndn/lp/lib/reassembler_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@lp.tgz/node_modules/@ndn/lp/lib/service_browser.js","webpack:///./node_modules/.pnpm/abortable-iterator@4.0.3/node_modules/abortable-iterator/dist/src/abort-error.js","webpack:///./node_modules/.pnpm/abortable-iterator@4.0.3/node_modules/abortable-iterator/dist/src/index.js","webpack:///./node_modules/.pnpm/get-iterator@2.0.0/node_modules/get-iterator/dist/src/index.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@l3face.tgz/node_modules/@ndn/l3face/lib/l3face_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@ws-transport.tgz/node_modules/@ndn/ws-transport/lib/ws-transport_browser.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@l3face.tgz/node_modules/@ndn/l3face/lib/rxtx-iterable_browser.js","webpack:///./src/main.js","webpack:///./node_modules/.pnpm/@ndnts-nightly.ndn.today@ws-transport.tgz/node_modules/@ndn/ws-transport/lib/ws_browser.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\nexports[\"default\"] = applyMixins;\n","module.exports = function(a, b) {\n  if (typeof a.compare === 'function') return a.compare(b)\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst event_iterator_1 = require(\"./event-iterator\");\nexports.EventIterator = event_iterator_1.EventIterator;\nfunction subscribe(event, options, evOptions) {\n    return new event_iterator_1.EventIterator(({ push }) => {\n        this.addEventListener(event, push, options);\n        return () => this.removeEventListener(event, push, options);\n    }, evOptions);\n}\nexports.subscribe = subscribe;\nexports.default = event_iterator_1.EventIterator;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nmodule.exports = function getIterator (obj) {\n  if (obj) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n","const getIterator = require('get-iterator')\nconst KEEP_ALIVE = {}\n\nmodule.exports = (getKeepAliveValue, options) => {\n  options = options || {}\n\n  return source => {\n    source = getIterator(source)\n    let sourceNext\n\n    return {\n      [Symbol.asyncIterator] () {\n        return this\n      },\n\n      async next () {\n        while (true) {\n          if (!sourceNext) {\n            sourceNext = source.next()\n          }\n\n          let timer\n          const timeout = new Promise(resolve => {\n            timer = setTimeout(() => resolve({ value: KEEP_ALIVE }), options.timeout || 1000)\n          })\n\n          const { done, value } = await Promise.race([timeout, sourceNext])\n          clearTimeout(timer)\n\n          if (done) return { done }\n\n          if (value === KEEP_ALIVE) {\n            if (!options.shouldKeepAlive || options.shouldKeepAlive()) {\n              return { value: getKeepAliveValue() }\n            }\n            continue\n          }\n\n          sourceNext = null\n          return { value }\n        }\n      },\n\n      return () {\n        if (source.return) return source.return()\n      }\n    }\n  }\n}\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","/**\n * Mnemonist DefaultMap\n * =====================\n *\n * JavaScript implementation of a default map that will return a constructed\n * value any time one tries to access an inexisting key. It's quite similar\n * to python's defaultdict.\n */\n\n/**\n * DefaultMap.\n *\n * @constructor\n */\nfunction DefaultMap(factory) {\n  if (typeof factory !== 'function')\n    throw new Error('mnemonist/DefaultMap.constructor: expecting a function.');\n\n  this.items = new Map();\n  this.factory = factory;\n  this.size = 0;\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nDefaultMap.prototype.clear = function() {\n\n  // Properties\n  this.items.clear();\n  this.size = 0;\n};\n\n/**\n * Method used to get the value set for given key. If the key does not exist,\n * the value will be created using the provided factory.\n *\n * @param  {any} key - Target key.\n * @return {any}\n */\nDefaultMap.prototype.get = function(key) {\n  var value = this.items.get(key);\n\n  if (typeof value === 'undefined') {\n    value = this.factory(key, this.size);\n    this.items.set(key, value);\n    this.size++;\n  }\n\n  return value;\n};\n\n/**\n * Method used to get the value set for given key. If the key does not exist,\n * a value won't be created.\n *\n * @param  {any} key - Target key.\n * @return {any}\n */\nDefaultMap.prototype.peek = function(key) {\n  return this.items.get(key);\n};\n\n/**\n * Method used to set a value for given key.\n *\n * @param  {any} key   - Target key.\n * @param  {any} value - Value.\n * @return {DefaultMap}\n */\nDefaultMap.prototype.set = function(key, value) {\n  this.items.set(key, value);\n  this.size = this.items.size;\n\n  return this;\n};\n\n/**\n * Method used to test the existence of a key in the map.\n *\n * @param  {any} key   - Target key.\n * @return {boolean}\n */\nDefaultMap.prototype.has = function(key) {\n  return this.items.has(key);\n};\n\n/**\n * Method used to delete target key.\n *\n * @param  {any} key   - Target key.\n * @return {boolean}\n */\nDefaultMap.prototype.delete = function(key) {\n  var deleted = this.items.delete(key);\n\n  this.size = this.items.size;\n\n  return deleted;\n};\n\n/**\n * Method used to iterate over each of the key/value pairs.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nDefaultMap.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  this.items.forEach(callback, scope);\n};\n\n/**\n * Iterators.\n */\nDefaultMap.prototype.entries = function() {\n  return this.items.entries();\n};\n\nDefaultMap.prototype.keys = function() {\n  return this.items.keys();\n};\n\nDefaultMap.prototype.values = function() {\n  return this.items.values();\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  DefaultMap.prototype[Symbol.iterator] = DefaultMap.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nDefaultMap.prototype.inspect = function() {\n  return this.items;\n};\n\nif (typeof Symbol !== 'undefined')\n  DefaultMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = DefaultMap.prototype.inspect;\n\n/**\n * Typical factories.\n */\nDefaultMap.autoIncrement = function() {\n  var i = 0;\n\n  return function() {\n    return i++;\n  };\n};\n\n/**\n * Exporting.\n */\nmodule.exports = DefaultMap;\n","/**\n * Mnemonist DefaultWeakMap\n * =========================\n *\n * JavaScript implementation of a default weak map that will return a constructed\n * value any time one tries to access an non-existing key. It is similar to\n * DefaultMap but uses ES6 WeakMap that only holds weak reference to keys.\n */\n\n/**\n * DefaultWeakMap.\n *\n * @constructor\n */\nfunction DefaultWeakMap(factory) {\n  if (typeof factory !== 'function')\n    throw new Error('mnemonist/DefaultWeakMap.constructor: expecting a function.');\n\n  this.items = new WeakMap();\n  this.factory = factory;\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nDefaultWeakMap.prototype.clear = function() {\n\n  // Properties\n  this.items = new WeakMap();\n};\n\n/**\n * Method used to get the value set for given key. If the key does not exist,\n * the value will be created using the provided factory.\n *\n * @param  {any} key - Target key.\n * @return {any}\n */\nDefaultWeakMap.prototype.get = function(key) {\n  var value = this.items.get(key);\n\n  if (typeof value === 'undefined') {\n    value = this.factory(key);\n    this.items.set(key, value);\n  }\n\n  return value;\n};\n\n/**\n * Method used to get the value set for given key. If the key does not exist,\n * a value won't be created.\n *\n * @param  {any} key - Target key.\n * @return {any}\n */\nDefaultWeakMap.prototype.peek = function(key) {\n  return this.items.get(key);\n};\n\n/**\n * Method used to set a value for given key.\n *\n * @param  {any} key   - Target key.\n * @param  {any} value - Value.\n * @return {DefaultMap}\n */\nDefaultWeakMap.prototype.set = function(key, value) {\n  this.items.set(key, value);\n  return this;\n};\n\n/**\n * Method used to test the existence of a key in the map.\n *\n * @param  {any} key   - Target key.\n * @return {boolean}\n */\nDefaultWeakMap.prototype.has = function(key) {\n  return this.items.has(key);\n};\n\n/**\n * Method used to delete target key.\n *\n * @param  {any} key   - Target key.\n * @return {boolean}\n */\nDefaultWeakMap.prototype.delete = function(key) {\n  return this.items.delete(key);\n};\n\n/**\n * Convenience known methods.\n */\nDefaultWeakMap.prototype.inspect = function() {\n  return this.items;\n};\n\nif (typeof Symbol !== 'undefined')\n  DefaultWeakMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = DefaultWeakMap.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = DefaultWeakMap;\n","module.exports = require('./lib/retry');","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n};\n","const INT2HEX = {};\nfor (let b = 0; b <= 0xFF; ++b) {\n    INT2HEX[b] = b.toString(16).padStart(2, \"0\").toUpperCase();\n}\nconst HEX2INT = {};\nfor (let b = 0; b <= 0xF; ++b) {\n    const ch = b.toString(16);\n    HEX2INT[ch.toLowerCase()] = b;\n    HEX2INT[ch.toUpperCase()] = b;\n}\n/** Convert byte array to upper-case hexadecimal string. */\nexport function toHex(buf) {\n    let s = \"\";\n    for (const b of buf) {\n        s += INT2HEX[b];\n    }\n    return s;\n}\n(function (toHex) {\n    /** Conversion table from byte (0x00~0xFF) to upper-case hexadecimal. */\n    toHex.TABLE = INT2HEX;\n})(toHex || (toHex = {}));\n/**\n * Convert hexadecimal string to byte array.\n *\n * If the input is not a valid hexadecimal string, result will be incorrect.\n */\nexport function fromHex(s) {\n    const b = new Uint8Array(s.length / 2);\n    for (let i = 0; i < b.length; ++i) {\n        b[i] = (HEX2INT[s[i * 2]] << 4) | HEX2INT[s[i * 2 + 1]];\n    }\n    return b;\n}\n(function (fromHex) {\n    /** Conversion table from hexadecimal digit (case insensitive) to nibble. */\n    fromHex.TABLE = HEX2INT;\n})(fromHex || (fromHex = {}));\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n/** Convert string to UTF-8 byte array. */\nexport function toUtf8(s) {\n    return textEncoder.encode(s);\n}\n/** Convert UTF-8 byte array to string. */\nexport function fromUtf8(buf) {\n    return textDecoder.decode(buf);\n}\n","function asArrayBufferView(T, a) {\n    if (a instanceof T) {\n        return a;\n    }\n    if (a instanceof ArrayBuffer) {\n        return new T(a);\n    }\n    return new T(a.buffer, a.byteOffset, a.byteLength);\n}\n/** Convert ArrayBuffer or ArrayBufferView to Uint8Array. */\nexport function asUint8Array(a) {\n    return asArrayBufferView(Uint8Array, a);\n}\n/** Convert ArrayBuffer or ArrayBufferView to DataView. */\nexport function asDataView(a) {\n    return asArrayBufferView(DataView, a);\n}\n","import { asDataView, toHex } from \"@ndn/util\";\nclass Nni1 {\n    n;\n    constructor(n) {\n        this.n = n;\n    }\n    encodeTo(encoder) {\n        encoder.prependRoom(1)[0] = this.n;\n    }\n}\nclass Nni2 {\n    n;\n    constructor(n) {\n        this.n = n;\n    }\n    encodeTo(encoder) {\n        asDataView(encoder.prependRoom(2)).setUint16(0, this.n);\n    }\n}\nclass Nni4 {\n    n;\n    constructor(n) {\n        this.n = n;\n    }\n    encodeTo(encoder) {\n        asDataView(encoder.prependRoom(4)).setUint32(0, this.n);\n    }\n}\nclass Nni8Number {\n    n;\n    constructor(n) {\n        this.n = n;\n    }\n    encodeTo(encoder) {\n        const dv = asDataView(encoder.prependRoom(8));\n        dv.setUint32(0, this.n / 0x100000000);\n        dv.setUint32(4, this.n);\n    }\n}\nclass Nni8Big {\n    n;\n    constructor(n) {\n        this.n = n;\n    }\n    encodeTo(encoder) {\n        asDataView(encoder.prependRoom(8)).setBigUint64(0, this.n);\n    }\n}\nfunction decode32(dv) {\n    switch (dv.byteLength) {\n        case 1: {\n            return dv.getUint8(0);\n        }\n        case 2: {\n            return dv.getUint16(0);\n        }\n        case 4: {\n            return dv.getUint32(0);\n        }\n    }\n    throw new Error(\"incorrect TLV-LENGTH of NNI\");\n}\nconst EncodeNniClass = {\n    1: Nni1,\n    2: Nni2,\n    4: Nni4,\n    8: Nni8Number,\n};\n/** Create Encodable from non-negative integer. */\nexport function NNI(n, { len, unsafe = false, } = {}) {\n    if (len) {\n        if (len === 8 && typeof n === \"bigint\") {\n            return new Nni8Big(n);\n        }\n        return new EncodeNniClass[len](Number(n));\n    }\n    if (typeof n === \"bigint\") {\n        switch (true) {\n            case n < 0x100000000n: {\n                n = Number(n);\n                break;\n            }\n            case n <= 0xffffffffffffffffn: {\n                return new Nni8Big(n);\n            }\n            default: {\n                throw new RangeError(\"NNI is too large\");\n            }\n        }\n    }\n    switch (true) {\n        case n < 0: {\n            throw new RangeError(\"NNI cannot be negative\");\n        }\n        case n < 0x100: {\n            return new Nni1(n);\n        }\n        case n < 0x10000: {\n            return new Nni2(n);\n        }\n        case n < 0x100000000: {\n            return new Nni4(n);\n        }\n        case n <= (unsafe ? 0xFFFFFFFFFFFFFFFF : Number.MAX_SAFE_INTEGER): { // eslint-disable-line @typescript-eslint/no-loss-of-precision\n            return new Nni8Number(n);\n        }\n        default: {\n            throw new RangeError(\"NNI is too large\");\n        }\n    }\n}\n(function (NNI) {\n    /** Determine if len is a valid length of encoded NNI. */\n    function isValidLength(len) {\n        return !!EncodeNniClass[len];\n    }\n    NNI.isValidLength = isValidLength;\n    function decode(value, { len, big = false, unsafe = false, } = {}) {\n        if (len && value.byteLength !== len) {\n            throw new Error(`incorrect TLV-LENGTH of NNI${len}`);\n        }\n        const dv = asDataView(value);\n        if (big) {\n            return dv.byteLength === 8 ? dv.getBigUint64(0) : BigInt(decode32(dv));\n        }\n        if (dv.byteLength === 8) {\n            const n = dv.getUint32(0) * 0x100000000 + dv.getUint32(4);\n            if (!unsafe && !Number.isSafeInteger(n)) {\n                throw new RangeError(`NNI is too large ${toHex(value)}`);\n            }\n            return n;\n        }\n        return decode32(dv);\n    }\n    NNI.decode = decode;\n    function constrain(n, typeName, limit0, limit1) {\n        const [min = 0, max = Number.MAX_SAFE_INTEGER] = typeof limit1 === \"number\" ? [limit0, limit1] : [0, limit0];\n        if (!(n >= min && n <= max)) {\n            throw new RangeError(`${n} is out of ${typeName} valid range`);\n        }\n        return Math.trunc(n);\n    }\n    NNI.constrain = constrain;\n})(NNI || (NNI = {}));\n","import { asDataView, fromUtf8 } from \"@ndn/util\";\nimport { NNI } from \"./nni_browser.js\";\nclass DecodedTlv {\n    type;\n    buf;\n    offsetT;\n    offsetV;\n    offsetE;\n    get length() {\n        return this.offsetE - this.offsetV;\n    }\n    get value() {\n        return this.buf.subarray(this.offsetV, this.offsetE);\n    }\n    get tlv() {\n        return this.buf.subarray(this.offsetT, this.offsetE);\n    }\n    get size() {\n        return this.offsetE - this.offsetT;\n    }\n    get decoder() {\n        return new Decoder(this.tlv);\n    }\n    get vd() {\n        return new Decoder(this.value);\n    }\n    get nni() {\n        return NNI.decode(this.value);\n    }\n    get nniBig() {\n        return NNI.decode(this.value, { big: true });\n    }\n    get text() {\n        return fromUtf8(this.value);\n    }\n    get before() {\n        return this.buf.subarray(0, this.offsetT);\n    }\n    get after() {\n        return this.buf.subarray(this.offsetE);\n    }\n    constructor(type, buf, offsetT, offsetV, offsetE) {\n        this.type = type;\n        this.buf = buf;\n        this.offsetT = offsetT;\n        this.offsetV = offsetV;\n        this.offsetE = offsetE;\n    }\n}\n/** TLV decoder. */\nexport class Decoder {\n    input;\n    /** Determine whether end of input has been reached. */\n    get eof() {\n        return this.offset >= this.input.length;\n    }\n    dv;\n    offset = 0;\n    constructor(input) {\n        this.input = input;\n        this.dv = asDataView(input);\n    }\n    /** Read TLV structure. */\n    read() {\n        const offsetT = this.offset;\n        const type = this.readVarNum();\n        const length = this.readVarNum();\n        const offsetV = this.offset;\n        if (length === undefined || (this.offset += length) > this.input.length) {\n            throw new Error(`TLV at offset ${offsetT} is incomplete`);\n        }\n        // length!==undefined implies type!==undefined\n        return new DecodedTlv(type, this.input, offsetT, offsetV, this.offset);\n    }\n    /** Read a Decodable object. */\n    decode(d) {\n        return d.decodeFrom(this);\n    }\n    readVarNum() {\n        if (this.eof) {\n            return undefined;\n        }\n        switch (this.input[this.offset]) {\n            case 0xFD: {\n                this.offset += 3;\n                if (this.offset > this.input.length) {\n                    return undefined;\n                }\n                return this.dv.getUint16(this.offset - 2);\n            }\n            case 0xFE: {\n                this.offset += 5;\n                if (this.offset > this.input.length) {\n                    return undefined;\n                }\n                return this.dv.getUint32(this.offset - 4);\n            }\n            case 0xFF: {\n                // JavaScript cannot reliably represent 64-bit integers\n                return undefined;\n            }\n            default: {\n                this.offset += 1;\n                return this.input[this.offset - 1];\n            }\n        }\n    }\n}\n","import { __importDefault, __importStar } from \"tslib\";\nimport _cjsDefaultImport0 from \"minimalistic-assert\"; const assert = __importDefault(_cjsDefaultImport0).default;\nexport { assert };\nexport { console, crypto, delay, concatBuffers } from \"./platform_browser.js\";\nexport * from \"./buffer_browser.js\";\nexport * from \"./closers_browser.js\";\nexport * from \"./crypto_browser.js\";\nexport * from \"./iter_browser.js\";\nexport * from \"./key-map_browser.js\";\nexport * from \"./string_browser.js\";\nexport * from \"./timer_browser.js\";\n","import { asDataView, assert } from \"@ndn/util\";\nfunction sizeofVarNum(n) {\n    if (n < 0xFD) {\n        return 1;\n    }\n    if (n <= 0xFFFF) {\n        return 3;\n    }\n    if (n <= 0xFFFFFFFF) {\n        return 5;\n    }\n    // 64-bit integers may lose precision in Number type, and it's rarely useful\n    throw new Error(\"VAR-NUMBER is too large\");\n}\nfunction writeVarNum(room, off, n) {\n    if (n < 0xFD) {\n        room[off++] = n;\n    }\n    else if (n <= 0xFFFF) {\n        room[off++] = 0xFD;\n        asDataView(room).setUint16(off, n);\n    }\n    else {\n        room[off++] = 0xFE;\n        asDataView(room).setUint32(off, n);\n    }\n}\n/** TLV encoder that accepts objects in reverse order. */\nexport class Encoder {\n    buf;\n    off;\n    /** Return encoding output size. */\n    get size() {\n        return this.buf.byteLength - this.off;\n    }\n    /** Obtain encoding output. */\n    get output() {\n        return this.slice();\n    }\n    constructor(initSize = 2048) {\n        this.buf = new ArrayBuffer(initSize);\n        this.off = initSize;\n    }\n    /** Obtain part of encoding output. */\n    slice(start = 0, length) {\n        return new Uint8Array(this.buf, this.off + start, length);\n    }\n    /**\n     * Make room to prepend an object.\n     * @param sizeofObject object size.\n     * @returns room to write object.\n     */\n    prependRoom(sizeofObject) {\n        if (this.off < sizeofObject) {\n            this.grow(sizeofObject);\n        }\n        this.off -= sizeofObject;\n        return this.slice(0, sizeofObject);\n    }\n    /** Prepend TLV-TYPE and TLV-LENGTH. */\n    prependTypeLength(tlvType, tlvLength) {\n        const sizeofT = sizeofVarNum(tlvType);\n        const sizeofL = sizeofVarNum(tlvLength);\n        const room = this.prependRoom(sizeofT + sizeofL);\n        writeVarNum(room, 0, tlvType);\n        writeVarNum(room, sizeofT, tlvLength);\n    }\n    /** Prepend TLV-VALUE. */\n    prependValue(...tlvValue) {\n        for (let i = tlvValue.length - 1; i >= 0; --i) {\n            this.encode(tlvValue[i]);\n        }\n    }\n    prependTlv(tlvType, omitEmpty, ...tlvValue) {\n        const hasOmitEmpty = omitEmpty === Encoder.OmitEmpty;\n        if (!hasOmitEmpty) {\n            tlvValue.unshift(omitEmpty);\n        }\n        const sizeBefore = this.size;\n        this.prependValue(...tlvValue);\n        const tlvLength = this.size - sizeBefore;\n        if (tlvLength > 0 || !hasOmitEmpty) {\n            this.prependTypeLength(tlvType, tlvLength);\n        }\n    }\n    /** Prepend an Encodable object. */\n    encode(obj) {\n        if (obj instanceof Uint8Array) {\n            this.prependRoom(obj.byteLength).set(obj);\n        }\n        else if (typeof obj === \"object\" && typeof obj.encodeTo === \"function\") {\n            obj.encodeTo(this);\n        }\n        else if (Array.isArray(obj)) {\n            if (typeof obj[0] === \"number\") {\n                this.prependTlv(...obj);\n            }\n            else {\n                this.prependValue(...obj);\n            }\n        }\n        else {\n            assert(obj === undefined || obj === false, \"obj is not Encodable\");\n        }\n    }\n    grow(sizeofRoom) {\n        const sizeofGrowth = 2048 + sizeofRoom;\n        const buf = new ArrayBuffer(sizeofGrowth + this.size);\n        new Uint8Array(buf, sizeofGrowth).set(this.output);\n        this.buf = buf;\n        this.off = sizeofGrowth;\n    }\n}\n(function (Encoder) {\n    Encoder.OmitEmpty = Symbol(\"OmitEmpty\");\n    /** Encode a single object into Uint8Array. */\n    function encode(obj, initBufSize) {\n        const encoder = new Encoder(initBufSize);\n        encoder.encode(obj);\n        return encoder.output;\n    }\n    Encoder.encode = encode;\n    /** Extract the encoding output of an element while writing to a larger encoder. */\n    function extract(obj, cb) {\n        return {\n            encodeTo(encoder) {\n                const sizeBefore = encoder.size;\n                encoder.encode(obj);\n                cb(encoder.slice(0, encoder.size - sizeBefore));\n            },\n        };\n    }\n    Encoder.extract = extract;\n})(Encoder || (Encoder = {}));\n","export const TT = {\n    Name: 0x07,\n    GenericNameComponent: 0x08,\n    ImplicitSha256DigestComponent: 0x01,\n    ParametersSha256DigestComponent: 0x02,\n    Interest: 0x05,\n    CanBePrefix: 0x21,\n    MustBeFresh: 0x12,\n    ForwardingHint: 0x1E,\n    Nonce: 0x0A,\n    InterestLifetime: 0x0C,\n    HopLimit: 0x22,\n    AppParameters: 0x24,\n    ISigInfo: 0x2C,\n    ISigValue: 0x2E,\n    Data: 0x06,\n    MetaInfo: 0x14,\n    ContentType: 0x18,\n    FreshnessPeriod: 0x19,\n    FinalBlock: 0x1A,\n    Content: 0x15,\n    DSigInfo: 0x16,\n    DSigValue: 0x17,\n    SigType: 0x1B,\n    KeyLocator: 0x1C,\n    KeyDigest: 0x1D,\n    SigNonce: 0x26,\n    SigTime: 0x28,\n    SigSeqNum: 0x2A,\n    Nack: 0x0320,\n    NackReason: 0x0321,\n};\nexport const SigType = {\n    Sha256: 0x00,\n    Sha256WithRsa: 0x01,\n    Sha256WithEcdsa: 0x03,\n    HmacWithSha256: 0x04,\n    Ed25519: 0x05,\n    Null: 0xC8,\n};\nexport const NackReason = {\n    Congestion: 50,\n    Duplicate: 100,\n    NoRoute: 150,\n};\n","import { __importDefault, __importStar } from \"tslib\";\nimport { Decoder, Encoder } from \"@ndn/tlv\";\nimport { fromHex, fromUtf8, toHex, toUtf8 } from \"@ndn/util\";\nimport _cjsDefaultImport0 from \"buffer-compare\"; const bufferCompare = __importDefault(_cjsDefaultImport0).default;\nimport { TT } from \"../an_browser.js\";\nfunction checkType(t) {\n    return Number.isInteger(t) && t >= 0x01 && t <= 0xFFFF;\n}\nfunction assertType(t) {\n    if (!checkType(t)) {\n        throw new Error(`Component TLV-TYPE ${t} out of range`);\n    }\n}\nconst CHAR_ENCODE = {};\nfor (let b = 0x00; b <= 0xFF; ++b) {\n    const s = String.fromCodePoint(b);\n    CHAR_ENCODE[b] = /[\\w.~-]/i.test(s) ? s : `%${toHex.TABLE[b]}`;\n}\nconst CODEPOINT_PERCENT = \"%\".codePointAt(0);\nconst CODEPOINT_PERIOD = \".\".codePointAt(0);\n/**\n * Name component.\n * This type is immutable.\n */\nexport class Component {\n    static decodeFrom(decoder) {\n        const { tlv } = decoder.read();\n        return new Component(tlv);\n    }\n    /** Parse from URI representation, or return existing Component. */\n    static from(input) {\n        if (input instanceof Component) {\n            return input;\n        }\n        let type = TT.GenericNameComponent;\n        let posValue = 0;\n        const posEqual = input.indexOf(\"=\");\n        if (posEqual >= 1) {\n            const iType = Number.parseInt(input, 10);\n            if (checkType(iType)) {\n                type = iType;\n                posValue = posEqual + 1;\n            }\n        }\n        const value = new Uint8Array(input.length - posValue);\n        let length = 0;\n        let hasNonPeriods = false;\n        for (let i = posValue; i < input.length;) {\n            let b = input.codePointAt(i);\n            hasNonPeriods ||= b !== CODEPOINT_PERIOD;\n            if (b === CODEPOINT_PERCENT) {\n                b = (fromHex.TABLE[input[i + 1]] << 4) | fromHex.TABLE[input[i + 2]];\n                i += 3;\n            }\n            else {\n                ++i;\n            }\n            value[length++] = b;\n        }\n        if (!hasNonPeriods && length >= 3) {\n            length -= 3;\n        }\n        return new Component(type, value.subarray(0, length));\n    }\n    /** Whole TLV. */\n    tlv;\n    /** TLV-TYPE. */\n    type;\n    /** TLV-VALUE. */\n    value;\n    /** TLV-LENGTH. */\n    get length() {\n        return this.value.length;\n    }\n    /** TLV-VALUE interpreted as UTF-8 string. */\n    get text() {\n        return fromUtf8(this.value);\n    }\n    constructor(arg1 = TT.GenericNameComponent, value = new Uint8Array()) {\n        if (arg1 instanceof Uint8Array) {\n            this.tlv = arg1;\n            const decoder = new Decoder(arg1);\n            ({ type: this.type, value: this.value } = decoder.read());\n        }\n        else {\n            this.type = arg1;\n            if (typeof value === \"string\") {\n                value = toUtf8(value);\n            }\n            this.tlv = Encoder.encode([this.type, value], 10 + value.length);\n            this.value = this.tlv.subarray(this.tlv.length - value.length);\n        }\n        assertType(this.type);\n    }\n    /** Get URI string. */\n    toString() {\n        let s = `${this.type}=`;\n        let hasNonPeriods = false;\n        for (const b of this.value) {\n            hasNonPeriods ||= b !== CODEPOINT_PERIOD;\n            s += CHAR_ENCODE[b];\n        }\n        if (!hasNonPeriods) {\n            s += \"...\";\n        }\n        return s;\n    }\n    encodeTo(encoder) {\n        encoder.encode(this.tlv);\n    }\n    /** Determine if component follows a naming convention. */\n    is(convention) {\n        return convention.match(this);\n    }\n    /** Convert with naming convention. */\n    as(convention) {\n        if (!convention.match(this)) {\n            throw new Error(\"component does not follow convention\");\n        }\n        return convention.parse(this);\n    }\n    /** Compare this component with other. */\n    compare(other) {\n        other = Component.from(other);\n        return 2 * Math.sign(this.type - other.type || this.length - other.length ||\n            bufferCompare(this.value, other.value));\n    }\n    /** Determine if this component equals other. */\n    equals(other) {\n        return this.compare(other) === Component.CompareResult.EQUAL;\n    }\n}\n(function (Component) {\n    /** Component compare result. */\n    let CompareResult;\n    (function (CompareResult) {\n        /** lhs is less than rhs */\n        CompareResult[CompareResult[\"LT\"] = -2] = \"LT\";\n        /** lhs and rhs are equal */\n        CompareResult[CompareResult[\"EQUAL\"] = 0] = \"EQUAL\";\n        /** lhs is greater than rhs */\n        CompareResult[CompareResult[\"GT\"] = 2] = \"GT\";\n    })(CompareResult = Component.CompareResult || (Component.CompareResult = {}));\n})(Component || (Component = {}));\n","import { Decoder, Encoder } from \"@ndn/tlv\";\nimport { toHex } from \"@ndn/util\";\nimport { TT } from \"../an_browser.js\";\nimport { Component } from \"./component_browser.js\";\n/**\n * Name.\n * This type is immutable.\n */\nexport class Name {\n    static decodeFrom(decoder) {\n        const { value } = decoder.read();\n        return new Name(value);\n    }\n    /** List of name components. */\n    comps;\n    constructor(arg1, parseComponent = Component.from) {\n        switch (true) {\n            case arg1 instanceof Name: {\n                const other = arg1;\n                this.comps = other.comps;\n                this.value_ = other.value_;\n                break;\n            }\n            case typeof arg1 === \"string\": {\n                const uri = arg1;\n                this.comps = uri.replace(/^(?:ndn:)?\\/*/, \"\").split(\"/\")\n                    .filter((comp) => comp !== \"\").map(parseComponent);\n                this.valueEncoderBufSize = uri.length + 4 * this.comps.length;\n                break;\n            }\n            case Array.isArray(arg1): {\n                this.comps = Array.from(arg1, Component.from);\n                break;\n            }\n            case arg1 instanceof Uint8Array: {\n                this.value_ = arg1;\n                const comps = [];\n                const decoder = new Decoder(this.value_);\n                while (!decoder.eof) {\n                    comps.push(decoder.decode(Component));\n                }\n                this.comps = comps;\n                break;\n            }\n            default: { // undefined\n                this.comps = [];\n                this.valueEncoderBufSize = 0;\n                break;\n            }\n        }\n    }\n    valueEncoderBufSize;\n    value_;\n    uri_;\n    hex_;\n    /** Number of name components. */\n    get length() {\n        return this.comps.length;\n    }\n    /** Name TLV-VALUE. */\n    get value() {\n        if (!this.value_) {\n            this.value_ = Encoder.encode(this.comps, this.valueEncoderBufSize ?? 256);\n        }\n        return this.value_;\n    }\n    /** Name TLV-VALUE hexadecimal representation, good for map keys. */\n    get valueHex() {\n        this.hex_ ??= toHex(this.value);\n        return this.hex_;\n    }\n    /** Retrieve i-th component. */\n    get(i) {\n        i = i < 0 ? i + this.length : i;\n        return this.comps[i];\n    }\n    /**\n     * Retrieve i-th component.\n     * @throws i-th component does not exist.\n     */\n    at(i) {\n        const comp = this.get(i);\n        if (!comp) {\n            throw new Error(`component ${i} out of range`);\n        }\n        return comp;\n    }\n    /** Get URI string. */\n    toString() {\n        this.uri_ ??= `/${this.comps.map((comp) => comp.toString()).join(\"/\")}`;\n        return this.uri_;\n    }\n    /** Get sub name [begin, end). */\n    slice(begin, end) {\n        return new Name(this.comps.slice(begin, end));\n    }\n    /** Get prefix of n components. */\n    getPrefix(n) {\n        return this.slice(0, n);\n    }\n    append(...args) {\n        if (args.length === 2 &&\n            typeof args[0].create === \"function\") {\n            return this.append(args[0].create(args[1]));\n        }\n        const suffix = args;\n        return new Name([...this.comps, ...suffix]);\n    }\n    /** Return a copy of Name with a component replaced. */\n    replaceAt(i, comp) {\n        const comps = [...this.comps];\n        comps.splice(i, 1, comp);\n        return new Name(comps);\n    }\n    /** Compare with other name. */\n    compare(other) {\n        other = Name.from(other);\n        const commonSize = Math.min(this.length, other.length);\n        const cmp = this.comparePrefix(other, commonSize);\n        if (cmp !== Name.CompareResult.EQUAL) {\n            return cmp;\n        }\n        if (this.length > commonSize) {\n            return Name.CompareResult.RPREFIX;\n        }\n        if (other.length > commonSize) {\n            return Name.CompareResult.LPREFIX;\n        }\n        return Name.CompareResult.EQUAL;\n    }\n    /** Determine if this name equals other. */\n    equals(other) {\n        other = Name.from(other);\n        if (this.hex_ !== undefined && other.hex_ !== undefined) {\n            return this.hex_ === other.hex_;\n        }\n        return this.length === other.length && this.comparePrefix(other, this.length) === Name.CompareResult.EQUAL;\n    }\n    /** Determine if this name is a prefix of other. */\n    isPrefixOf(other) {\n        other = Name.from(other);\n        return this.length <= other.length && this.comparePrefix(other, this.length) === Name.CompareResult.EQUAL;\n    }\n    comparePrefix(other, n) {\n        for (let i = 0; i < n; ++i) {\n            const cmp = this.comps[i].compare(other.comps[i]);\n            if (cmp !== Component.CompareResult.EQUAL) {\n                return cmp;\n            }\n        }\n        return Name.CompareResult.EQUAL;\n    }\n    encodeTo(encoder) {\n        if (this.value_) {\n            encoder.prependTlv(TT.Name, this.value_);\n        }\n        else {\n            encoder.prependTlv(TT.Name, ...this.comps);\n        }\n    }\n}\n(function (Name) {\n    function isNameLike(obj) {\n        return obj instanceof Name || typeof obj === \"string\";\n    }\n    Name.isNameLike = isNameLike;\n    function from(input) {\n        return input instanceof Name ? input : new Name(input);\n    }\n    Name.from = from;\n    /** Name compare result. */\n    let CompareResult;\n    (function (CompareResult) {\n        /** lhs is less than, but not a prefix of rhs */\n        CompareResult[CompareResult[\"LT\"] = -2] = \"LT\";\n        /** lhs is a prefix of rhs */\n        CompareResult[CompareResult[\"LPREFIX\"] = -1] = \"LPREFIX\";\n        /** lhs and rhs are equal */\n        CompareResult[CompareResult[\"EQUAL\"] = 0] = \"EQUAL\";\n        /** rhs is a prefix of lhs */\n        CompareResult[CompareResult[\"RPREFIX\"] = 1] = \"RPREFIX\";\n        /** rhs is less than, but not a prefix of lhs */\n        CompareResult[CompareResult[\"GT\"] = 2] = \"GT\";\n    })(CompareResult = Name.CompareResult || (Name.CompareResult = {}));\n})(Name || (Name = {}));\n","/**\n * Map that transforms keys.\n *\n * K: input key type.\n * V: value type.\n * I: indexable key type.\n * L: lookup key type.\n */\nexport class KeyMap {\n    keyOf;\n    /**\n     * Constructor.\n     * @param keyOf function to transform input key to indexable key.\n     */\n    constructor(keyOf) {\n        this.keyOf = keyOf;\n    }\n    m = new Map();\n    get size() { return this.m.size; }\n    has(key) {\n        return this.m.has(this.keyOf(key));\n    }\n    get(key) {\n        return this.m.get(this.keyOf(key))?.[1];\n    }\n    set(key, value) {\n        this.m.set(this.keyOf(key), [key, value]);\n        return this;\n    }\n    delete(key) {\n        return this.m.delete(this.keyOf(key));\n    }\n    [Symbol.iterator]() {\n        return this.m.values();\n    }\n}\n/**\n * MultiMap that transforms keys.\n *\n * K: input key type.\n * V: value type.\n * I: indexable key type.\n * L: lookup key type.\n */\nexport class KeyMultiMap {\n    /**\n     * Constructor.\n     * @param keyOf function to transform input key to indexable key.\n     */\n    constructor(keyOf) {\n        this.m = new KeyMap(keyOf);\n    }\n    m;\n    size_ = 0;\n    /** Number of distinct keys. */\n    get dimension() { return this.m.size; }\n    /** Number of values. */\n    get size() { return this.size_; }\n    /** Count values associated with a key. */\n    count(key) {\n        return this.m.get(key)?.size ?? 0;\n    }\n    /** List values associated with a key. */\n    list(key) {\n        return this.m.get(key) ?? new Set();\n    }\n    /**\n     * Add a key-value pair.\n     * Values are stored in a Set, so duplicates are skipped.\n     * @returns count(key) after the operation.\n     */\n    add(key, value) {\n        let c = this.m.get(key);\n        if (!c) {\n            c = new Set();\n            this.m.set(key, c);\n        }\n        const n = c.size;\n        c.add(value);\n        this.size_ += c.size - n;\n        return c.size;\n    }\n    /**\n     * Remove a key-value pair.\n     * No-op if key-value does not exist.\n     * @returns count(key) after the operation.\n     */\n    remove(key, value) {\n        const c = this.m.get(key);\n        if (!c) {\n            return 0;\n        }\n        const n = c.size;\n        c.delete(value);\n        this.size_ += c.size - n;\n        if (c.size === 0) {\n            this.m.delete(key);\n        }\n        return c.size;\n    }\n    /** Iterate over key and associated values. */\n    associations() {\n        return this.m[Symbol.iterator]();\n    }\n    /** Iterate over key-value pairs. */\n    *[Symbol.iterator]() {\n        for (const [key, values] of this.associations()) {\n            for (const value of values) {\n                yield [key, value];\n            }\n        }\n    }\n}\n/** Container that associates a key with multiple distinct values. */\nexport class MultiMap extends KeyMultiMap {\n    constructor() {\n        super((k) => k);\n    }\n}\n/**\n * MultiSet that transforms keys.\n *\n * K: input key type.\n * I: indexable key type.\n * L: lookup key type.\n */\nexport class KeyMultiSet {\n    /**\n     * Constructor.\n     * @param keyOf function to transform input key to indexable key.\n     */\n    constructor(keyOf) {\n        this.m = new KeyMap(keyOf);\n    }\n    m;\n    size_ = 0;\n    /** Number of distinct keys. */\n    get dimension() { return this.m.size; }\n    /** Number of values. */\n    get size() { return this.size_; }\n    /** Count occurrences of a key. */\n    count(key) {\n        return this.m.get(key) ?? 0;\n    }\n    /**\n     * Add a key.\n     * @returns number of occurrences after the operation.\n     */\n    add(key) {\n        const n = this.count(key) + 1;\n        this.m.set(key, n);\n        ++this.size_;\n        return n;\n    }\n    /**\n     * Remove a key.\n     * No-op if key does not exist.\n     * @returns number of occurrences after the operation.\n     */\n    remove(key) {\n        let n = this.count(key);\n        if (n === 0) {\n            return n;\n        }\n        --this.size_;\n        --n;\n        if (n === 0) {\n            this.m.delete(key);\n        }\n        else {\n            this.m.set(key, n);\n        }\n        return n;\n    }\n    /** Iterate over key and number of occurrences. */\n    multiplicities() {\n        return this.m[Symbol.iterator]();\n    }\n}\n","import { KeyMap, KeyMultiMap, KeyMultiSet } from \"@ndn/util\";\nfunction keyOf(nameOrHex) {\n    return typeof nameOrHex === \"string\" ? nameOrHex : nameOrHex.valueHex;\n}\n/**\n * Map keyed by name.\n * Lookups may accept either name or name.valueHex.\n */\nexport class NameMap extends KeyMap {\n    constructor() {\n        super(keyOf);\n    }\n}\n/**\n * MultiMap keyed by name.\n * Lookups may accept either name or name.valueHex.\n */\nexport class NameMultiMap extends KeyMultiMap {\n    constructor() {\n        super(keyOf);\n    }\n}\n/**\n * MultiSet keyed by name.\n * Lookups may accept either name or name.valueHex.\n */\nexport class NameMultiSet extends KeyMultiSet {\n    constructor() {\n        super(keyOf);\n    }\n}\n","/** Pretty-print TLV-TYPE number. */\nexport function printTT(tlvType) {\n    const s = tlvType.toString(16).toUpperCase();\n    if (tlvType < 0xFD) {\n        return `0x${s.padStart(2, \"0\")}`;\n    }\n    if (tlvType <= 0xFFFF) {\n        return `0x${s.padStart(4, \"0\")}`;\n    }\n    return `0x${s.padStart(8, \"0\")}`;\n}\n","import { assert } from \"@ndn/util\";\nimport { printTT } from \"./string_browser.js\";\nconst AUTO_ORDER_SKIP = 100;\nfunction nest(evd) {\n    return (target, { decoder }) => { evd.decode(target, decoder); };\n}\nfunction isCritical(tt) {\n    return tt <= 0x1F || tt % 2 === 1;\n}\n/** TLV-VALUE decoder that understands Packet Format v0.3 evolvability guidelines. */\nexport class EvDecoder {\n    typeName;\n    topTT;\n    rules = new Map();\n    requiredTT = new Set();\n    nextOrder = AUTO_ORDER_SKIP;\n    isCritical = isCritical;\n    unknownHandler;\n    /** Callbacks before decoding TLV-VALUE. */\n    beforeObservers = [];\n    /** Callbacks after decoding TLV-VALUE. */\n    afterObservers = [];\n    /**\n     * Constructor.\n     * @param typeName type name, used in error messages.\n     * @param topTT if specified, check top-level TLV-TYPE to be in this list.\n     */\n    constructor(typeName, topTT = []) {\n        this.typeName = typeName;\n        this.topTT = Array.isArray(topTT) ? topTT : [topTT];\n    }\n    /**\n     * Add a decoding rule.\n     * @param tt TLV-TYPE to match this rule.\n     * @param cb callback or nested EvDecoder to handle element TLV.\n     * @param options additional rule options.\n     */\n    add(tt, cb, { order = (this.nextOrder += AUTO_ORDER_SKIP), required = false, repeat = false, } = {}) {\n        assert(!this.rules.has(tt), \"duplicate rule for same TLV-TYPE\");\n        this.rules.set(tt, {\n            cb: cb instanceof EvDecoder ? nest(cb) : cb,\n            order,\n            required,\n            repeat,\n        });\n        if (required) {\n            this.requiredTT.add(tt);\n        }\n        return this;\n    }\n    /** Set callback to determine whether TLV-TYPE is critical. */\n    setIsCritical(cb) {\n        this.isCritical = cb;\n        return this;\n    }\n    /** Set callback to handle unknown elements. */\n    setUnknown(cb) {\n        this.unknownHandler = cb;\n        return this;\n    }\n    /** Decode TLV to target object. */\n    decode(target, decoder) {\n        const topTlv = decoder.read();\n        const { type, vd } = topTlv;\n        if (this.topTT.length > 0 && !this.topTT.includes(type)) {\n            throw new Error(`TLV-TYPE ${printTT(type)} is not ${this.typeName}`);\n        }\n        return this.decodeV(target, vd, topTlv);\n    }\n    /** Decode TLV-VALUE to target object. */\n    decodeValue(target, vd) {\n        return this.decodeV(target, vd);\n    }\n    decodeV(target, vd, topTlv) {\n        for (const cb of this.beforeObservers) {\n            cb(target, topTlv);\n        }\n        let currentOrder = 0;\n        const foundTT = new Set();\n        const missingTT = new Set(this.requiredTT);\n        while (!vd.eof) {\n            const tlv = vd.read();\n            const tt = tlv.type;\n            const rule = this.rules.get(tt);\n            if (!rule) {\n                if (!this.unknownHandler?.(target, tlv, currentOrder)) {\n                    this.handleUnrecognized(tt, \"unknown\");\n                }\n                continue;\n            }\n            if (currentOrder > rule.order) {\n                this.handleUnrecognized(tt, \"out of order\");\n                continue;\n            }\n            currentOrder = rule.order;\n            if (!rule.repeat && foundTT.has(tt)) {\n                throw new Error(`TLV-TYPE ${printTT(tt)} cannot repeat in ${this.typeName}`);\n            }\n            foundTT.add(tt);\n            missingTT.delete(tt);\n            rule.cb(target, tlv);\n        }\n        if (missingTT.size > 0) {\n            throw new Error(`TLV-TYPE ${Array.from(missingTT, printTT).join(\",\")} missing in ${this.typeName}`);\n        }\n        for (const cb of this.afterObservers) {\n            cb(target, topTlv);\n        }\n        return target;\n    }\n    handleUnrecognized(tt, reason) {\n        if (this.isCritical(tt)) {\n            throw new Error(`TLV-TYPE ${printTT(tt)} is ${reason} in ${this.typeName}`);\n        }\n    }\n}\n","import { __importDefault, __importStar } from \"tslib\";\nimport _cjsDefaultImport0 from \"minimalistic-assert\"; const assert = __importDefault(_cjsDefaultImport0).default;\nexport const console = globalThis.console;\nexport const crypto = globalThis.crypto;\n// https://codahale.com/a-lesson-in-timing-attacks/\nexport function timingSafeEqual(a, b) {\n    // length has been checked by caller\n    let result = 0;\n    for (let i = 0; i < a.byteLength; ++i) {\n        result |= a[i] ^ b[i];\n    }\n    return result === 0;\n}\nexport function delay(after, value) {\n    return new Promise((resolve) => setTimeout(resolve, after, value));\n}\nexport function concatBuffers(list, totalLength) {\n    totalLength ??= list.reduce((l, { byteLength }) => l + byteLength, 0);\n    const c = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const part of list) {\n        c.set(part, offset);\n        offset += part.byteLength;\n    }\n    assert.equal(offset, totalLength);\n    return c;\n}\n","import { crypto, timingSafeEqual as platformTimingSafeEqual } from \"./platform_browser.js\";\n/** Timing-safe equality comparison. */\nexport function timingSafeEqual(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    return platformTimingSafeEqual(a, b);\n}\n/** SHA256 digest. */\nexport async function sha256(input) {\n    const digest = await crypto.subtle.digest(\"SHA-256\", input);\n    return new Uint8Array(digest);\n}\n","import { Encoder, EvDecoder } from \"@ndn/tlv\";\nimport { TT } from \"./an_browser.js\";\nimport { Name } from \"./name/mod_browser.js\";\nconst EVD = new EvDecoder(\"FwHint\")\n    .add(TT.Name, (t, { decoder }) => t.push(decoder.decode(Name)), { repeat: true });\n/** ForwardingHint in Interest. */\nexport class FwHint {\n    static decodeValue(vd) {\n        const t = new FwHint();\n        EVD.decodeValue(t.delegations, vd);\n        return t;\n    }\n    constructor(arg) {\n        if (Array.isArray(arg)) {\n            for (const name of arg) {\n                this.delegations.push(Name.from(name));\n            }\n        }\n        else if (arg instanceof FwHint) {\n            this.delegations = [...arg.delegations];\n        }\n        else if (Name.isNameLike(arg)) {\n            this.delegations = [Name.from(arg)];\n        }\n    }\n    delegations = [];\n    encodeTo(encoder) {\n        encoder.prependTlv(TT.ForwardingHint, Encoder.OmitEmpty, ...this.delegations);\n    }\n}\n","export const FIELDS = Symbol(\"FIELDS\");\nexport function definePublicFields(typ, fieldDefs) {\n    for (const [field, clearing] of Object.entries(fieldDefs)) {\n        Object.defineProperty(typ.prototype, field, {\n            enumerable: true,\n            get() {\n                return this[FIELDS][field];\n            },\n            set(v) {\n                const f = this[FIELDS];\n                f[field] = v;\n                for (const c of clearing) {\n                    f[c] = undefined;\n                }\n            },\n        });\n    }\n}\n","import { fromHex, toHex } from \"@ndn/util\";\nimport { TT } from \"../an_browser.js\";\nimport { Component } from \"./component_browser.js\";\nconst DIGEST_LENGTH = 32;\nclass DigestComp {\n    tt;\n    altUriPrefix;\n    altUriRegex;\n    constructor(tt, altUriPrefix) {\n        this.tt = tt;\n        this.altUriPrefix = altUriPrefix;\n        this.altUriRegex = new RegExp(`^${altUriPrefix}=([0-9a-fA-F]{${2 * DIGEST_LENGTH}})$`);\n    }\n    match(comp) {\n        return comp.type === this.tt && comp.length === DIGEST_LENGTH;\n    }\n    create(v) {\n        if (v.length !== DIGEST_LENGTH) {\n            throw new Error(`digest length must be ${DIGEST_LENGTH}`);\n        }\n        return new Component(this.tt, v);\n    }\n    parse(comp) {\n        return comp.value;\n    }\n    toAltUri(comp) {\n        return `${this.altUriPrefix}=${toHex(comp.value).toLowerCase()}`;\n    }\n    fromAltUri(input) {\n        const m = this.altUriRegex.exec(input);\n        if (!m) {\n            return undefined;\n        }\n        return new Component(this.tt, fromHex(m[1]));\n    }\n}\nclass ImplicitDigestComp extends DigestComp {\n    constructor() {\n        super(TT.ImplicitSha256DigestComponent, \"sha256digest\");\n    }\n    /** Remove ImplicitDigest if present at last component. */\n    strip(name) {\n        if (name.get(-1)?.is(this)) {\n            return name.getPrefix(-1);\n        }\n        return name;\n    }\n}\n/** ImplicitSha256DigestComponent */\nexport const ImplicitDigest = new ImplicitDigestComp();\nconst PARAMS_PLACEHOLDER_TAG = Symbol(\"ParametersSha256DigestComponent.placeholder\");\nclass ParamsDigestComp extends DigestComp {\n    /** ParamsDigest placeholder during Interest encoding. */\n    PLACEHOLDER;\n    constructor() {\n        super(TT.ParametersSha256DigestComponent, \"params-sha256\");\n        this.PLACEHOLDER = Object.assign(new Component(TT.ParametersSha256DigestComponent), { [PARAMS_PLACEHOLDER_TAG]: true });\n    }\n    /** Determine if comp is a ParamsDigest placeholder. */\n    isPlaceholder(comp) {\n        return !!comp[PARAMS_PLACEHOLDER_TAG];\n    }\n    /** Find ParamsDigest or placeholder in name. */\n    findIn(name, matchPlaceholder = true) {\n        return name.comps.findIndex((comp) => this.match(comp) ||\n            (matchPlaceholder && this.isPlaceholder(comp)));\n    }\n}\n/** ParametersSha256DigestComponent */\nexport const ParamsDigest = new ParamsDigestComp();\n","import { Encoder, EvDecoder } from \"@ndn/tlv\";\nimport { TT } from \"./an_browser.js\";\nimport { Name } from \"./name/mod_browser.js\";\nconst EVD = new EvDecoder(\"KeyLocator\", TT.KeyLocator)\n    .add(TT.Name, (t, { value }) => t.name = new Name(value))\n    .add(TT.KeyDigest, (t, { value }) => t.digest = value);\n/** KeyLocator in SigInfo. */\nexport class KeyLocator {\n    static decodeFrom(decoder) {\n        return EVD.decode(new KeyLocator(), decoder);\n    }\n    name;\n    digest;\n    constructor(...args) {\n        for (const arg of args) {\n            if (Name.isNameLike(arg)) {\n                this.name = Name.from(arg);\n            }\n            else if (arg instanceof Uint8Array) {\n                this.digest = arg;\n            }\n            else if (arg instanceof KeyLocator) {\n                Object.assign(this, arg);\n            }\n            else {\n                throw new Error(\"unknown KeyLocator constructor argument\");\n            }\n        }\n    }\n    encodeTo(encoder) {\n        encoder.prependTlv(TT.KeyLocator, Encoder.OmitEmpty, this.name, [TT.KeyDigest, Encoder.OmitEmpty, this.digest]);\n    }\n}\n(function (KeyLocator) {\n    function isCtorArg(arg) {\n        return arg instanceof KeyLocator || Name.isNameLike(arg) || arg instanceof Uint8Array;\n    }\n    KeyLocator.isCtorArg = isCtorArg;\n    /**\n     * Extract KeyLocator name.\n     * @throws KeyLocator is missing or does not have Name.\n     */\n    function mustGetName(kl) {\n        const name = kl?.name;\n        if (!name) {\n            throw new Error(\"KeyLocator does not have name\");\n        }\n        return name;\n    }\n    KeyLocator.mustGetName = mustGetName;\n})(KeyLocator || (KeyLocator = {}));\n","import { __importDefault, __importStar } from \"tslib\";\nimport _cjsDefaultImport0 from \"mnemonist/default-weak-map.js\"; const DefaultWeakMap = __importDefault(_cjsDefaultImport0).default;\nconst RECORDS = new DefaultWeakMap(() => new Map());\nexport var Extensible;\n(function (Extensible) {\n    Extensible.TAG = Symbol(\"Extensible\");\n    /** Clone extension fields of src to dst. */\n    function cloneRecord(dst, src) {\n        RECORDS.set(dst, new Map(RECORDS.get(src)));\n    }\n    Extensible.cloneRecord = cloneRecord;\n})(Extensible || (Extensible = {}));\nexport var Extension;\n(function (Extension) {\n    /** Retrieve value of an extension field. */\n    function get(obj, tt) {\n        return RECORDS.get(obj).get(tt);\n    }\n    Extension.get = get;\n    /** Assign value of an extension field. */\n    function set(obj, tt, value) {\n        RECORDS.get(obj).set(tt, value);\n    }\n    Extension.set = set;\n    /** Clear value of an extension field. */\n    function clear(obj, tt) {\n        RECORDS.get(obj).delete(tt);\n    }\n    Extension.clear = clear;\n})(Extension || (Extension = {}));\n/** Registry of known extension fields of a parent TLV element. */\nexport class ExtensionRegistry {\n    table = new Map();\n    /** Add an extension. */\n    registerExtension = (ext) => {\n        this.table.set(ext.tt, ext);\n    };\n    /** Remove an extension. */\n    unregisterExtension = (tt) => {\n        this.table.delete(tt);\n    };\n    /** UnknownElementCallback for EvDecoder. */\n    decodeUnknown = (target, tlv, order) => {\n        const { type: tt } = tlv;\n        const ext = this.table.get(tt);\n        if (!ext) {\n            return false;\n        }\n        const record = RECORDS.get(target);\n        record.set(tt, ext.decode(target, tlv, record.get(tt)));\n        return true;\n    };\n    /** Encode extension fields. */\n    encode(source) {\n        const record = RECORDS.peek(source);\n        if (!record) {\n            return [];\n        }\n        const fields = [];\n        for (const [tt, value] of record) {\n            const ext = this.table.get(tt);\n            if (!ext) {\n                throw new Error(`unknown extension type ${tt}`);\n            }\n            fields.push({ tt, value, ext });\n        }\n        fields.sort((a, b) => (a.ext.order ?? a.tt) - (b.ext.order ?? b.tt));\n        return fields.map(({ value, ext }) => ext.encode(source, value));\n    }\n}\n","import { Encoder, EvDecoder, Extensible, ExtensionRegistry, NNI } from \"@ndn/tlv\";\nimport { assert, crypto } from \"@ndn/util\";\nimport { SigType, TT } from \"./an_browser.js\";\nimport { KeyLocator } from \"./key-locator_browser.js\";\nconst EXTENSIONS = new ExtensionRegistry();\nconst EVD = new EvDecoder(\"SigInfo\", [TT.ISigInfo, TT.DSigInfo])\n    .add(TT.SigType, (t, { nni }) => t.type = nni, { required: true })\n    .add(TT.KeyLocator, (t, { decoder }) => t.keyLocator = decoder.decode(KeyLocator))\n    .add(TT.SigNonce, (t, { value }) => t.nonce = value)\n    .add(TT.SigTime, (t, { nni }) => t.time = nni)\n    .add(TT.SigSeqNum, (t, { nniBig }) => t.seqNum = nniBig)\n    .setUnknown(EXTENSIONS.decodeUnknown);\n/** SignatureInfo on Interest or Data. */\nexport class SigInfo {\n    static decodeFrom(decoder) {\n        return EVD.decode(new SigInfo(), decoder);\n    }\n    type = SigType.Null;\n    keyLocator;\n    nonce;\n    time;\n    seqNum;\n    [Extensible.TAG] = EXTENSIONS;\n    /**\n     * Construct from flexible arguments.\n     *\n     * Arguments can include, in any order:\n     * - SigInfo to copy from\n     * - number as SigType\n     * - KeyLocator, or Name/URI/KeyDigest to construct KeyLocator\n     * - SigInfo.Nonce(v)\n     * - SigInfo.Time(v)\n     * - SigInfo.SeqNum(v)\n     */\n    constructor(...args) {\n        const klArgs = [];\n        for (const arg of args) {\n            if (typeof arg === \"number\") {\n                this.type = arg;\n            }\n            else if (KeyLocator.isCtorArg(arg)) {\n                klArgs.push(arg);\n            }\n            else if (arg instanceof SigInfo) {\n                Object.assign(this, arg);\n                Extensible.cloneRecord(this, arg);\n            }\n            else if (arg[ctorAssign]) {\n                arg[ctorAssign](this);\n            }\n            else {\n                throw new Error(\"unknown SigInfo constructor argument\");\n            }\n        }\n        if (klArgs.length > 0) {\n            this.keyLocator = new KeyLocator(...klArgs);\n        }\n    }\n    /**\n     * Create an Encodable.\n     * @param tt either TT.ISigInfo or TT.DSigInfo.\n     */\n    encodeAs(tt) {\n        return {\n            encodeTo: (encoder) => this.encodeTo(encoder, tt),\n        };\n    }\n    encodeTo(encoder, tt) {\n        encoder.prependTlv(tt, [TT.SigType, NNI(this.type)], this.keyLocator, [TT.SigNonce, Encoder.OmitEmpty, this.nonce], this.time !== undefined && [TT.SigTime, NNI(this.time)], this.seqNum !== undefined && [TT.SigSeqNum, NNI(this.seqNum)], ...EXTENSIONS.encode(this));\n    }\n}\nconst ctorAssign = Symbol(\"SigInfo.ctorAssign\");\n(function (SigInfo) {\n    function Nonce(v) {\n        return {\n            [ctorAssign](si) {\n                si.nonce = v instanceof Uint8Array ? v : generateNonce(v);\n            },\n        };\n    }\n    SigInfo.Nonce = Nonce;\n    /** Generate a random nonce. */\n    function generateNonce(size = 8) {\n        assert(size >= 1);\n        return crypto.getRandomValues(new Uint8Array(size));\n    }\n    SigInfo.generateNonce = generateNonce;\n    function Time(v = Date.now()) {\n        return {\n            [ctorAssign](si) { si.time = v; },\n        };\n    }\n    SigInfo.Time = Time;\n    function SeqNum(v) {\n        return {\n            [ctorAssign](si) { si.seqNum = v; },\n        };\n    }\n    SigInfo.SeqNum = SeqNum;\n    SigInfo.registerExtension = EXTENSIONS.registerExtension;\n    SigInfo.unregisterExtension = EXTENSIONS.unregisterExtension;\n})(SigInfo || (SigInfo = {}));\n","import { sha256, timingSafeEqual } from \"@ndn/util\";\nimport { SigType } from \"../an_browser.js\";\nimport { KeyLocator } from \"../key-locator_browser.js\";\nimport { SigInfo } from \"../sig-info_browser.js\";\nexport var LLSign;\n(function (LLSign) {\n    LLSign.OP = Symbol(\"LLSign.OP\");\n})(LLSign || (LLSign = {}));\nexport var LLVerify;\n(function (LLVerify) {\n    LLVerify.OP = Symbol(\"LLVerify.OP\");\n})(LLVerify || (LLVerify = {}));\nexport var Signer;\n(function (Signer) {\n    /**\n     * Put SigInfo on packet if it does not exist.\n     * @param pkt target packet.\n     * @param sigType optionally set sigType.\n     * @param keyLocator optionally set keyLocator; false to delete KeyLocator.\n     */\n    function putSigInfo(pkt, sigType, keyLocator) {\n        pkt.sigInfo ??= new SigInfo();\n        if (sigType !== undefined) {\n            pkt.sigInfo.type = sigType;\n        }\n        if (keyLocator === false) {\n            pkt.sigInfo.keyLocator = undefined;\n        }\n        else if (keyLocator !== undefined) {\n            pkt.sigInfo.keyLocator = new KeyLocator(keyLocator);\n        }\n        return pkt.sigInfo;\n    }\n    Signer.putSigInfo = putSigInfo;\n})(Signer || (Signer = {}));\nexport var Verifier;\n(function (Verifier) {\n    /** Throw if packet does not have expected SigType. */\n    function checkSigType(pkt, expectedSigType) {\n        if (pkt.sigInfo?.type !== expectedSigType) {\n            throw new Error(`packet does not have SigType ${expectedSigType}`);\n        }\n    }\n    Verifier.checkSigType = checkSigType;\n    /** Throw bad signature error if not OK. */\n    function throwOnBadSig(ok) {\n        if (!ok) {\n            throw new Error(\"bad signature value\");\n        }\n    }\n    Verifier.throwOnBadSig = throwOnBadSig;\n})(Verifier || (Verifier = {}));\n/** Signer and Verifier that do nothing. */\nexport const noopSigning = {\n    sign() {\n        return Promise.resolve();\n    },\n    verify() {\n        return Promise.resolve();\n    },\n};\n/** Signer and Verifier for SigType.Sha256 digest. */\nexport const digestSigning = {\n    sign(pkt) {\n        Signer.putSigInfo(pkt, SigType.Sha256, false);\n        return pkt[LLSign.OP]((input) => sha256(input));\n    },\n    async verify(pkt) {\n        Verifier.checkSigType(pkt, SigType.Sha256);\n        return pkt[LLVerify.OP](async (input, sig) => {\n            const h = await sha256(input);\n            const ok = timingSafeEqual(sig, h);\n            Verifier.throwOnBadSig(ok);\n        });\n    },\n};\n/**\n * Signer for SigType.Null, a packet that is not signed.\n * @see https://redmine.named-data.net/projects/ndn-tlv/wiki/NullSignature\n */\nexport const nullSigner = {\n    sign(pkt) {\n        Signer.putSigInfo(pkt, SigType.Null, false);\n        pkt.sigValue = new Uint8Array();\n        return Promise.resolve();\n    },\n};\n","import { Encoder, EvDecoder, NNI } from \"@ndn/tlv\";\nimport { assert, sha256 } from \"@ndn/util\";\nimport { TT } from \"./an_browser.js\";\nimport { FwHint } from \"./fwhint_browser.js\";\nimport { definePublicFields, FIELDS } from \"./impl-public-fields_browser.js\";\nimport { Name, ParamsDigest } from \"./name/mod_browser.js\";\nimport { LLSign, LLVerify } from \"./security/signing_browser.js\";\nimport { SigInfo } from \"./sig-info_browser.js\";\nconst HOPLIMIT_MAX = 255;\nclass Fields {\n    constructor(...args) {\n        for (const arg of args) {\n            if (Name.isNameLike(arg)) {\n                this.name = Name.from(arg);\n            }\n            else if (arg instanceof FwHint) {\n                this.fwHint = new FwHint(arg);\n            }\n            else if (arg instanceof Uint8Array) {\n                this.appParameters = arg;\n            }\n            else if (arg instanceof Interest) {\n                Object.assign(this, arg[FIELDS]);\n            }\n            else if (arg[ctorAssign]) {\n                arg[ctorAssign](this);\n            }\n            else {\n                throw new Error(\"unknown Interest constructor argument\");\n            }\n        }\n    }\n    name = new Name();\n    canBePrefix = false;\n    mustBeFresh = false;\n    fwHint;\n    get nonce() { return this.nonce_; }\n    set nonce(v) { this.nonce_ = v && NNI.constrain(v, \"Nonce\", 0xFFFFFFFF); }\n    nonce_;\n    get lifetime() { return this.lifetime_; }\n    set lifetime(v) { this.lifetime_ = NNI.constrain(v, \"InterestLifetime\"); }\n    lifetime_ = Interest.DefaultLifetime;\n    get hopLimit() { return this.hopLimit_; }\n    set hopLimit(v) { this.hopLimit_ = NNI.constrain(v, \"HopLimit\", HOPLIMIT_MAX); }\n    hopLimit_ = HOPLIMIT_MAX;\n    appParameters;\n    sigInfo;\n    sigValue = new Uint8Array();\n    paramsPortion;\n    signedPortion;\n}\nconst EVD = new EvDecoder(\"Interest\", TT.Interest)\n    .add(TT.Name, (t, { decoder }) => t.name = decoder.decode(Name), { required: true })\n    .add(TT.CanBePrefix, (t) => t.canBePrefix = true)\n    .add(TT.MustBeFresh, (t) => t.mustBeFresh = true)\n    .add(TT.ForwardingHint, (t, { vd }) => t.fwHint = FwHint.decodeValue(vd))\n    .add(TT.Nonce, (t, { value }) => t.nonce = NNI.decode(value, { len: 4 }))\n    .add(TT.InterestLifetime, (t, { nni }) => t.lifetime = nni)\n    .add(TT.HopLimit, (t, { value }) => t.hopLimit = NNI.decode(value, { len: 1 }))\n    .add(TT.AppParameters, (t, { value, tlv, after }) => {\n    if (ParamsDigest.findIn(t.name, false) < 0) {\n        throw new Error(\"ParamsDigest missing in parameterized Interest\");\n    }\n    t.appParameters = value;\n    assert(tlv.buffer === after.buffer);\n    t.paramsPortion = new Uint8Array(tlv.buffer, tlv.byteOffset, tlv.byteLength + after.byteLength);\n})\n    .add(TT.ISigInfo, (t, { decoder }) => t.sigInfo = decoder.decode(SigInfo))\n    .add(TT.ISigValue, (t, { value, tlv }) => {\n    if (!t.name.get(-1)?.is(ParamsDigest)) {\n        throw new Error(\"ParamsDigest missing or out of place in signed Interest\");\n    }\n    if (!t.paramsPortion) {\n        throw new Error(\"AppParameters missing in signed Interest\");\n    }\n    if (!t.sigInfo) {\n        throw new Error(\"ISigInfo missing in signed Interest\");\n    }\n    assert(tlv.buffer === t.paramsPortion.buffer);\n    t.sigValue = value;\n    // t.name.value should be readily available during decoding;\n    // t.name.getPrefix(-1).value would require re-encoding from components\n    const signedPart0 = t.name.value.subarray(0, -t.name.get(-1).tlv.byteLength);\n    const signedPart1 = new Uint8Array(tlv.buffer, t.paramsPortion.byteOffset, tlv.byteOffset - t.paramsPortion.byteOffset);\n    t.signedPortion = new Uint8Array(signedPart0.byteLength + signedPart1.byteLength);\n    t.signedPortion.set(signedPart0, 0);\n    t.signedPortion.set(signedPart1, signedPart0.byteLength);\n});\n/** Interest packet. */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class Interest {\n    /**\n     * Construct from flexible arguments.\n     *\n     * Arguments can include, in any order:\n     * - Interest to copy from\n     * - Name or name URI\n     * - Interest.CanBePrefix\n     * - Interest.MustBeFresh\n     * - FwHint\n     * - Interest.Nonce(v)\n     * - Interest.Lifetime(v)\n     * - Interest.HopLimit(v)\n     * - Uint8Array as AppParameters\n     */\n    constructor(...args) {\n        this[FIELDS] = new Fields(...args);\n    }\n    [FIELDS];\n    static decodeFrom(decoder) {\n        const interest = new Interest();\n        EVD.decode(interest[FIELDS], decoder);\n        return interest;\n    }\n    encodeTo(encoder) {\n        const { name, canBePrefix, mustBeFresh, fwHint, nonce, lifetime, hopLimit, appParameters } = this[FIELDS];\n        if (name.length === 0) {\n            throw new Error(\"invalid empty Interest name\");\n        }\n        if (appParameters && ParamsDigest.findIn(name, false) < 0) {\n            throw new Error(\"ParamsDigest missing\");\n        }\n        encoder.prependTlv(TT.Interest, name, canBePrefix && [TT.CanBePrefix], mustBeFresh && [TT.MustBeFresh], fwHint, [TT.Nonce, NNI(nonce ?? Interest.generateNonce(), { len: 4 })], lifetime !== Interest.DefaultLifetime && [TT.InterestLifetime, NNI(lifetime)], hopLimit !== HOPLIMIT_MAX && [TT.HopLimit, NNI(hopLimit, { len: 1 })], ...this.encodeParamsPortion());\n    }\n    encodeParamsPortion() {\n        const { appParameters, sigInfo, sigValue } = this[FIELDS];\n        if (!appParameters) {\n            return [];\n        }\n        const w = [[TT.AppParameters, appParameters]];\n        if (sigInfo) {\n            w.push(sigInfo.encodeAs(TT.ISigInfo), [TT.ISigValue, sigValue]);\n        }\n        return w;\n    }\n    appendParamsDigestPlaceholder() {\n        const f = this[FIELDS];\n        this.name = f.name.append(ParamsDigest.PLACEHOLDER);\n        return f.name.length - 1;\n    }\n    async updateParamsDigest() {\n        const f = this[FIELDS];\n        let pdIndex = ParamsDigest.findIn(f.name);\n        if (pdIndex < 0) {\n            pdIndex = this.appendParamsDigestPlaceholder();\n        }\n        f.appParameters ??= new Uint8Array();\n        f.paramsPortion = Encoder.encode(this.encodeParamsPortion());\n        const d = await sha256(f.paramsPortion);\n        f.name = f.name.replaceAt(pdIndex, ParamsDigest.create(d));\n    }\n    async validateParamsDigest(requireAppParameters = false) {\n        const { appParameters, paramsPortion, name } = this[FIELDS];\n        if (!appParameters) {\n            if (requireAppParameters) {\n                throw new Error(\"AppParameters is missing\");\n            }\n            return;\n        }\n        if (!paramsPortion) {\n            throw new Error(\"parameters portion is empty\");\n        }\n        const pdComp = name.at(ParamsDigest.findIn(name, false));\n        const d = await sha256(paramsPortion);\n        // This is not a constant-time comparison. It's for integrity purpose only.\n        if (!pdComp.equals(ParamsDigest.create(d))) {\n            throw new Error(\"incorrect ParamsDigest\");\n        }\n    }\n    async [LLSign.OP](sign) {\n        const f = this[FIELDS];\n        let pdIndex = ParamsDigest.findIn(f.name);\n        if (pdIndex < 0) {\n            pdIndex = this.appendParamsDigestPlaceholder();\n        }\n        else if (pdIndex !== f.name.length - 1) {\n            throw new Error(\"ParamsDigest out of place for signed Interest\");\n        }\n        f.signedPortion = Encoder.encode([\n            ...f.name.getPrefix(-1).comps,\n            [TT.AppParameters, f.appParameters],\n            f.sigInfo?.encodeAs(TT.ISigInfo),\n        ]);\n        this.sigValue = await sign(f.signedPortion);\n        return this.updateParamsDigest();\n    }\n    async [LLVerify.OP](verify) {\n        const { signedPortion, sigValue } = this[FIELDS];\n        await this.validateParamsDigest();\n        if (!signedPortion) {\n            throw new Error(\"SignedPortion is missing\");\n        }\n        await verify(signedPortion, sigValue);\n    }\n}\ndefinePublicFields(Interest, {\n    name: [\"signedPortion\"],\n    canBePrefix: [],\n    mustBeFresh: [],\n    fwHint: [],\n    nonce: [],\n    lifetime: [],\n    hopLimit: [],\n    appParameters: [\"paramsPortion\", \"signedPortion\"],\n    sigInfo: [\"paramsPortion\", \"signedPortion\"],\n    sigValue: [\"paramsPortion\"],\n});\nconst ctorAssign = Symbol(\"Interest.ctorAssign\");\n(function (Interest) {\n    /** Generate a random nonce. */\n    function generateNonce() {\n        return Math.trunc(Math.random() * 0x100000000);\n    }\n    Interest.generateNonce = generateNonce;\n    /** Default InterestLifetime. */\n    Interest.DefaultLifetime = 4000;\n    /** Constructor argument to set CanBePrefix flag. */\n    Interest.CanBePrefix = {\n        [ctorAssign](f) { f.canBePrefix = true; },\n    };\n    /** Constructor argument to set MustBeFresh flag. */\n    Interest.MustBeFresh = {\n        [ctorAssign](f) { f.mustBeFresh = true; },\n    };\n    /** Constructor argument to set Nonce field. */\n    function Nonce(v = generateNonce()) {\n        return {\n            [ctorAssign](f) { f.nonce = v; },\n        };\n    }\n    Interest.Nonce = Nonce;\n    /** Constructor argument to set InterestLifetime field. */\n    function Lifetime(v) {\n        return {\n            [ctorAssign](f) { f.lifetime = v; },\n        };\n    }\n    Interest.Lifetime = Lifetime;\n    /** Constructor argument to set HopLimit field. */\n    function HopLimit(v) {\n        return {\n            [ctorAssign](f) { f.hopLimit = v; },\n        };\n    }\n    Interest.HopLimit = HopLimit;\n    /** Turn ModifyFields to ModifyFunc; return ModifyFunc as-is. */\n    function makeModifyFunc(input) {\n        if (!input) {\n            return () => undefined;\n        }\n        if (typeof input === \"function\") {\n            return input;\n        }\n        const patch = {};\n        for (const key of [\"canBePrefix\", \"mustBeFresh\", \"fwHint\", \"lifetime\", \"hopLimit\"]) {\n            if (input[key] !== undefined) {\n                patch[key] = input[key];\n            }\n        }\n        return (interest) => {\n            Object.assign(interest, patch);\n        };\n    }\n    Interest.makeModifyFunc = makeModifyFunc;\n})(Interest || (Interest = {}));\n","import { Encoder, EvDecoder, NNI } from \"@ndn/tlv\";\nimport { sha256 } from \"@ndn/util\";\nimport { TT } from \"./an_browser.js\";\nimport { definePublicFields, FIELDS } from \"./impl-public-fields_browser.js\";\nimport { Component, ImplicitDigest, Name } from \"./name/mod_browser.js\";\nimport { LLSign, LLVerify } from \"./security/signing_browser.js\";\nimport { SigInfo } from \"./sig-info_browser.js\";\nclass Fields {\n    constructor(...args) {\n        let isFinalBlock = false;\n        for (const arg of args) {\n            if (Name.isNameLike(arg)) {\n                this.name = Name.from(arg);\n            }\n            else if (arg instanceof Uint8Array) {\n                this.content = arg;\n            }\n            else if (arg === Data.FinalBlock) {\n                isFinalBlock = true;\n            }\n            else if (arg instanceof Data) {\n                Object.assign(this, arg[FIELDS]);\n            }\n            else if (arg[ctorAssign]) {\n                arg[ctorAssign](this);\n            }\n            else {\n                throw new Error(\"unknown Data constructor argument\");\n            }\n        }\n        this.isFinalBlock = isFinalBlock;\n    }\n    name = new Name();\n    get contentType() { return this.contentType_; }\n    set contentType(v) { this.contentType_ = NNI.constrain(v, \"ContentType\"); }\n    contentType_ = 0;\n    get freshnessPeriod() { return this.freshnessPeriod_; }\n    set freshnessPeriod(v) { this.freshnessPeriod_ = NNI.constrain(v, \"FreshnessPeriod\"); }\n    freshnessPeriod_ = 0;\n    finalBlockId;\n    /** Determine whether FinalBlockId equals the last name component. */\n    get isFinalBlock() {\n        return !!this.finalBlockId && this.name.length > 0 &&\n            this.finalBlockId.equals(this.name.get(-1));\n    }\n    /**\n     * Setting to false deletes FinalBlockId.\n     *\n     * Setting to true assigns FinalBlockId to be the last name component.\n     * It is not allowed if the name is empty.\n     */\n    set isFinalBlock(v) {\n        if (!v) {\n            this.finalBlockId = undefined;\n            return;\n        }\n        if (this.name.length === 0) {\n            throw new Error(\"cannot set FinalBlockId when Name is empty\");\n        }\n        this.finalBlockId = this.name.get(-1);\n    }\n    content = new Uint8Array();\n    sigInfo = new SigInfo();\n    sigValue = new Uint8Array();\n    signedPortion;\n    topTlv;\n    topTlvDigest;\n}\nconst EVD = new EvDecoder(\"Data\", TT.Data)\n    .add(TT.Name, (t, { decoder }) => t.name = decoder.decode(Name), { required: true })\n    .add(TT.MetaInfo, new EvDecoder(\"MetaInfo\")\n    .add(TT.ContentType, (t, { nni }) => t.contentType = nni)\n    .add(TT.FreshnessPeriod, (t, { nni }) => t.freshnessPeriod = nni)\n    .add(TT.FinalBlock, (t, { vd }) => t.finalBlockId = vd.decode(Component)))\n    .add(TT.Content, (t, { value }) => t.content = value)\n    .add(TT.DSigInfo, (t, { decoder }) => t.sigInfo = decoder.decode(SigInfo), { required: true })\n    .add(TT.DSigValue, (t, { value, before }) => {\n    t.sigValue = value;\n    t.signedPortion = before;\n}, { required: true });\nEVD.beforeObservers.push((t, tlv) => t.topTlv = tlv.tlv);\n/** Data packet. */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class Data {\n    /**\n     * Construct from flexible arguments.\n     *\n     * Arguments can include, in any order unless otherwise specified:\n     * - Data to copy from\n     * - Name or name URI\n     * - Data.ContentType(v)\n     * - Data.FreshnessPeriod(v)\n     * - Data.FinalBlock (must appear after Name)\n     * - Uint8Array as Content\n     */\n    constructor(...args) {\n        this[FIELDS] = new Fields(...args);\n    }\n    [FIELDS];\n    static decodeFrom(decoder) {\n        const data = new Data();\n        EVD.decode(data[FIELDS], decoder);\n        return data;\n    }\n    encodeTo(encoder) {\n        const f = this[FIELDS];\n        if (f.topTlv) {\n            encoder.encode(f.topTlv);\n            return;\n        }\n        encoder.encode(Encoder.extract([\n            TT.Data,\n            Encoder.extract(this.encodeSignedPortion(), (output) => f.signedPortion = output),\n            [TT.DSigValue, f.sigValue],\n        ], (output) => f.topTlv = output));\n    }\n    encodeSignedPortion() {\n        const { name, contentType, freshnessPeriod, finalBlockId, content, sigInfo } = this[FIELDS];\n        return [\n            name,\n            [\n                TT.MetaInfo, Encoder.OmitEmpty,\n                contentType > 0 ? [TT.ContentType, NNI(contentType)] : undefined,\n                freshnessPeriod > 0 ? [TT.FreshnessPeriod, NNI(freshnessPeriod)] : undefined,\n                finalBlockId && [TT.FinalBlock, finalBlockId],\n            ],\n            content.byteLength > 0 ? [TT.Content, content] : undefined,\n            sigInfo.encodeAs(TT.DSigInfo),\n        ];\n    }\n    getImplicitDigest() {\n        return this[FIELDS].topTlvDigest;\n    }\n    async computeImplicitDigest() {\n        let digest = this.getImplicitDigest();\n        if (!digest) {\n            const f = this[FIELDS];\n            if (!f.topTlv) {\n                Encoder.encode(this);\n            }\n            digest = await sha256(f.topTlv);\n            f.topTlvDigest = digest;\n        }\n        return digest;\n    }\n    getFullName() {\n        const digest = this.getImplicitDigest();\n        if (!digest) {\n            return undefined;\n        }\n        return this[FIELDS].name.append(ImplicitDigest, digest);\n    }\n    async computeFullName() {\n        await this.computeImplicitDigest();\n        return this.getFullName();\n    }\n    /**\n     * Determine if a Data can satisfy an Interest.\n     * @returns a Promise that will be resolved with the result.\n     */\n    async canSatisfy(interest) {\n        if (interest.mustBeFresh && this.freshnessPeriod <= 0) {\n            return false;\n        }\n        if (interest.canBePrefix ? interest.name.isPrefixOf(this.name) : interest.name.equals(this.name)) {\n            return true;\n        }\n        if (interest.name.length === this.name.length + 1 && interest.name.get(-1).is(ImplicitDigest)) {\n            const fullName = this.getFullName();\n            if (!fullName) {\n                return interest.name.equals(await this.computeFullName());\n            }\n            return interest.name.equals(fullName);\n        }\n        return false;\n    }\n    async [LLSign.OP](sign) {\n        const signedPortion = Encoder.encode(this.encodeSignedPortion());\n        this[FIELDS].signedPortion = signedPortion;\n        this.sigValue = await sign(signedPortion);\n    }\n    async [LLVerify.OP](verify) {\n        const { signedPortion, sigValue } = this[FIELDS];\n        if (!sigValue) {\n            throw new Error(\"SigValue is missing\");\n        }\n        if (!signedPortion) {\n            throw new Error(\"SignedPortion is missing\");\n        }\n        await verify(signedPortion, sigValue);\n    }\n}\nconst clearingFields = [\"topTlv\", \"topTlvDigest\", \"signedPortion\"];\ndefinePublicFields(Data, {\n    name: clearingFields,\n    contentType: clearingFields,\n    freshnessPeriod: clearingFields,\n    finalBlockId: clearingFields,\n    isFinalBlock: clearingFields,\n    content: clearingFields,\n    sigInfo: clearingFields,\n    sigValue: clearingFields.slice(0, 2),\n});\nconst ctorAssign = Symbol(\"Data.ctorAssign\");\n(function (Data) {\n    /** Constructor argument to set ContentType field. */\n    function ContentType(v) {\n        return {\n            [ctorAssign](f) { return f.contentType = v; },\n        };\n    }\n    Data.ContentType = ContentType;\n    /** Constructor argument to set FreshnessPeriod field. */\n    function FreshnessPeriod(v) {\n        return {\n            [ctorAssign](f) { return f.freshnessPeriod = v; },\n        };\n    }\n    Data.FreshnessPeriod = FreshnessPeriod;\n    /** Constructor argument to set the current packet as FinalBlock. */\n    Data.FinalBlock = Symbol(\"Data.FinalBlock\");\n})(Data || (Data = {}));\n","import { EvDecoder, NNI } from \"@ndn/tlv\";\nimport { NackReason, TT } from \"./an_browser.js\";\nconst EVD = new EvDecoder(\"NackHeader\", TT.Nack)\n    .add(TT.NackReason, (t, { nni }) => t.reason = nni);\n/** Nack header. */\nexport class NackHeader {\n    get reason() { return this.reason_; }\n    set reason(v) { this.reason_ = NNI.constrain(v, \"Reason\"); }\n    reason_ = 0;\n    static decodeFrom(decoder) {\n        return EVD.decode(new NackHeader(), decoder);\n    }\n    constructor(reason = 0) {\n        this.reason = reason;\n    }\n    encodeTo(encoder) {\n        encoder.prependTlv(TT.Nack, this.reason_ > 0 && [TT.NackReason, NNI(this.reason_)]);\n    }\n}\n/** Nack packet. */\nexport class Nack {\n    interest;\n    get reason() { return this.header.reason; }\n    set reason(v) { this.header.reason = v; }\n    header;\n    constructor(interest, header = NackReason.NoRoute) {\n        this.interest = interest;\n        if (typeof header === \"number\") {\n            this.header = new NackHeader(header);\n        }\n        else {\n            this.header = header;\n        }\n    }\n}\n","/** Yield all values from an iterable but catch any error. */\nexport async function* safeIter(iterable, onError) {\n    try {\n        yield* iterable;\n    }\n    catch (err) {\n        onError?.(err);\n    }\n}\n/**\n * Map and flatten once.\n * This differs from flatMap in streaming-iterables, which recursively flattens the result.\n */\nexport async function* flatMapOnce(f, iterable) {\n    for await (const item of iterable) {\n        yield* f(item);\n    }\n}\n","// ported from https://www.npmjs.com/package/fast-fifo\nclass FixedFIFO {\n    constructor(hwm) {\n        if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n            throw new Error('Max size for a FixedFIFO should be a power of two');\n        }\n        this.buffer = new Array(hwm);\n        this.mask = hwm - 1;\n        this.top = 0;\n        this.btm = 0;\n        this.next = null;\n    }\n    push(data) {\n        if (this.buffer[this.top] !== undefined) {\n            return false;\n        }\n        this.buffer[this.top] = data;\n        this.top = (this.top + 1) & this.mask;\n        return true;\n    }\n    shift() {\n        const last = this.buffer[this.btm];\n        if (last === undefined) {\n            return undefined;\n        }\n        this.buffer[this.btm] = undefined;\n        this.btm = (this.btm + 1) & this.mask;\n        return last;\n    }\n    isEmpty() {\n        return this.buffer[this.btm] === undefined;\n    }\n}\nexport class FIFO {\n    constructor(options = {}) {\n        this.hwm = options.splitLimit ?? 16;\n        this.head = new FixedFIFO(this.hwm);\n        this.tail = this.head;\n        this.size = 0;\n    }\n    calculateSize(obj) {\n        if (obj?.byteLength != null) {\n            return obj.byteLength;\n        }\n        return 1;\n    }\n    push(val) {\n        if (val?.value != null) {\n            this.size += this.calculateSize(val.value);\n        }\n        if (!this.head.push(val)) {\n            const prev = this.head;\n            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);\n            this.head.push(val);\n        }\n    }\n    shift() {\n        let val = this.tail.shift();\n        if (val === undefined && (this.tail.next != null)) {\n            const next = this.tail.next;\n            this.tail.next = null;\n            this.tail = next;\n            val = this.tail.shift();\n        }\n        if (val?.value != null) {\n            this.size -= this.calculateSize(val.value);\n        }\n        return val;\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n}\n//# sourceMappingURL=fifo.js.map","/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\nimport { FIFO } from './fifo.js';\nexport function pushable(options = {}) {\n    const getNext = (buffer) => {\n        const next = buffer.shift();\n        if (next == null) {\n            return { done: true };\n        }\n        if (next.error != null) {\n            throw next.error;\n        }\n        return {\n            done: next.done === true,\n            // @ts-expect-error\n            value: next.value\n        };\n    };\n    return _pushable(getNext, options);\n}\nexport function pushableV(options = {}) {\n    const getNext = (buffer) => {\n        let next;\n        const values = [];\n        while (!buffer.isEmpty()) {\n            next = buffer.shift();\n            if (next == null) {\n                break;\n            }\n            if (next.error != null) {\n                throw next.error;\n            }\n            if (next.done === false) {\n                // @ts-expect-error\n                values.push(next.value);\n            }\n        }\n        if (next == null) {\n            return { done: true };\n        }\n        return {\n            done: next.done === true,\n            value: values\n        };\n    };\n    return _pushable(getNext, options);\n}\nfunction _pushable(getNext, options) {\n    options = options ?? {};\n    let onEnd = options.onEnd;\n    let buffer = new FIFO();\n    let pushable;\n    let onNext;\n    let ended;\n    const waitNext = async () => {\n        if (!buffer.isEmpty()) {\n            return getNext(buffer);\n        }\n        if (ended) {\n            return { done: true };\n        }\n        return await new Promise((resolve, reject) => {\n            onNext = (next) => {\n                onNext = null;\n                buffer.push(next);\n                try {\n                    resolve(getNext(buffer));\n                }\n                catch (err) {\n                    reject(err);\n                }\n                return pushable;\n            };\n        });\n    };\n    const bufferNext = (next) => {\n        if (onNext != null) {\n            return onNext(next);\n        }\n        buffer.push(next);\n        return pushable;\n    };\n    const bufferError = (err) => {\n        buffer = new FIFO();\n        if (onNext != null) {\n            return onNext({ error: err });\n        }\n        buffer.push({ error: err });\n        return pushable;\n    };\n    const push = (value) => {\n        if (ended) {\n            return pushable;\n        }\n        // @ts-expect-error `byteLength` is not declared on PushType\n        if (options?.objectMode !== true && value?.byteLength == null) {\n            throw new Error('objectMode was not true but tried to push non-Uint8Array value');\n        }\n        return bufferNext({ done: false, value });\n    };\n    const end = (err) => {\n        if (ended)\n            return pushable;\n        ended = true;\n        return (err != null) ? bufferError(err) : bufferNext({ done: true });\n    };\n    const _return = () => {\n        buffer = new FIFO();\n        end();\n        return { done: true };\n    };\n    const _throw = (err) => {\n        end(err);\n        return { done: true };\n    };\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next: waitNext,\n        return: _return,\n        throw: _throw,\n        push,\n        end,\n        get readableLength() {\n            return buffer.size;\n        }\n    };\n    if (onEnd == null) {\n        return pushable;\n    }\n    const _pushable = pushable;\n    pushable = {\n        [Symbol.asyncIterator]() { return this; },\n        next() {\n            return _pushable.next();\n        },\n        throw(err) {\n            _pushable.throw(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        return() {\n            _pushable.return();\n            if (onEnd != null) {\n                onEnd();\n                onEnd = undefined;\n            }\n            return { done: true };\n        },\n        push,\n        end(err) {\n            _pushable.end(err);\n            if (onEnd != null) {\n                onEnd(err);\n                onEnd = undefined;\n            }\n            return pushable;\n        },\n        get readableLength() {\n            return _pushable.readableLength;\n        }\n    };\n    return pushable;\n}\n//# sourceMappingURL=index.js.map","async function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = (duration) => {\n    let timeoutId;\n    return [\n        new Promise(resolve => {\n            timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n        }),\n        () => {\n            clearTimeout(timeoutId);\n        },\n    ];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n    const startTimer = () => {\n        deleteTimer();\n        [timer, clearTimer] = createTimer(timeout);\n    };\n    const deleteTimer = () => {\n        if (clearTimer) {\n            clearTimer();\n        }\n        timer = undefined;\n    };\n    pendingData = iterator.next();\n    while (true) {\n        const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n        if (res === TIMEOUT || res.done) {\n            // Flush early (before we reach the batch size)\n            if (batchData.length) {\n                yield batchData;\n                batchData = [];\n            }\n            deleteTimer();\n            // And exit appropriately\n            if (res !== TIMEOUT) {\n                // done\n                break;\n            }\n            continue;\n        }\n        // Fetch next item early doors (before we potentially yield)\n        pendingData = iterator.next();\n        // Then handle the value\n        batchData.push(res.value);\n        if (batchData.length === 1) {\n            // Start timer once we have at least 1 item ready to go\n            startTimer();\n        }\n        if (batchData.length === size) {\n            yield batchData;\n            batchData = [];\n            deleteTimer();\n            continue;\n        }\n    }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n        return _batchWithTimeout(size, timeout, iterable);\n    }\n    // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n    return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const _val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const _val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _drop(count, iterable) {\n    let skipped = 0;\n    for await (const val of iterable) {\n        if (skipped < count) {\n            skipped++;\n            continue;\n        }\n        yield await val;\n    }\n}\nfunction* _syncDrop(count, iterable) {\n    let skipped = 0;\n    for (const val of iterable) {\n        if (skipped < count) {\n            skipped++;\n            continue;\n        }\n        yield val;\n    }\n}\nfunction drop(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => drop(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _drop(count, iterable);\n    }\n    return _syncDrop(count, iterable);\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\n/**\n * Returns a new iterator by pulling every item out of `iterable` (and all its sub iterables) and yielding them depth-first. Checks for the iterable interfaces and iterates it if it exists. If the value is a string it is not iterated as that ends up in an infinite loop. Errors from the source `iterable` are raised immediately.\n\n*note*: Typescript doesn't have recursive types but you can nest iterables as deep as you like.\n\n```ts\nimport { flatten } from 'streaming-iterables'\n\nfor await (const item of flatten([1, 2, [3, [4, 5], 6])) {\n  console.log(item)\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n```\n */\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\n/**\n * Wraps the stream in an async iterator or returns the stream if it already is an async iterator.\n\n*note*: Since Node 10, streams already async iterators. This function may be used to ensure compatibility with older versions of Node.\n\n```ts\nimport { fromStream } from 'streaming-iterables'\nimport { createReadStream } from 'fs'\n\nconst pokeLog = fromStream(createReadStream('./pokedex-operating-system.log'))\n\nfor await (const pokeData of pokeLog) {\n  console.log(pokeData) // Buffer(...)\n}\n```\n * @deprecated This method is deprecated since, node 10 is out of LTS. It may be removed in an upcoming major release.\n */\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\n/**\n * Combine multiple iterators into a single iterable. Reads one item off each iterable in order repeatedly until they are all exhausted. If you care less about order and want them faster see `parallelMerge()`.\n */\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\n/**\n *Combine multiple iterators into a single iterable. Reads one item off of every iterable and yields them as they resolve. This is useful for pulling items out of a collection of iterables as soon as they're available. Errors `iterables` are raised immediately.\n\n```ts\nimport { parallelMerge } from 'streaming-iterables'\nimport { getPokemon, getTransformer } from 'iterable-pokedex'\n\n// pokemon are much faster to load btw\nconst heros = parallelMerge(getPokemon(), getTransformer())\nfor await (const hero of heros) {\n  console.log(hero)\n}\n// charmander\n// bulbasaur\n// megatron\n// pikachu\n// eevee\n// bumblebee\n// jazz\n```\n */\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _takeLast(count, iterable) {\n    const buffer = [];\n    for await (const res of iterable) {\n        buffer.push(res);\n        if (buffer.length > count) {\n            buffer.shift();\n        }\n    }\n    while (buffer.length) {\n        yield await buffer.shift();\n    }\n}\nfunction* _syncTakeLast(count, iterable) {\n    const buffer = [];\n    for (const res of iterable) {\n        buffer.push(res);\n        if (buffer.length > count) {\n            buffer.shift();\n        }\n    }\n    while (buffer.length) {\n        yield buffer.shift();\n    }\n}\nfunction takeLast(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => takeLast(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _takeLast(count, iterable);\n    }\n    return _syncTakeLast(count, iterable);\n}\n\nasync function* _takeWhile(predicate, iterable) {\n    for await (const data of iterable) {\n        if (!await predicate(data)) {\n            return;\n        }\n        yield data;\n    }\n}\nfunction takeWhile(predicate, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _takeWhile(predicate, curriedIterable);\n    }\n    return _takeWhile(predicate, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n        throw new TypeError('Expected `limit` to be a finite number');\n    }\n    if (limit <= 0) {\n        throw new TypeError('Expected `limit` to be greater than 0');\n    }\n    if (!Number.isFinite(interval)) {\n        throw new TypeError('Expected `interval` to be a finite number');\n    }\n    return (async function* __throttle() {\n        let sent = 0;\n        let time;\n        for await (const val of iterable) {\n            if (sent < limit) {\n                if (typeof time === 'undefined') {\n                    time = Date.now();\n                }\n                sent++;\n                yield val;\n                continue;\n            }\n            // Only wait if the interval hasn't already passed while we were\n            // yielding the previous values.\n            const elapsedMs = Date.now() - (time || 0);\n            const waitFor = interval - elapsedMs;\n            if (waitFor > 0) {\n                await sleep(waitFor);\n            }\n            time = Date.now();\n            sent = 1;\n            yield val;\n        }\n    })();\n}\nfunction throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n    }\n    return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, drop, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, takeLast, takeWhile, tap, throttle, time, transform, writeToStream };\n","import { EventEmitter } from \"events\";\nimport { Data, Interest, Nack, Name, NameMultiSet } from \"@ndn/packet\";\nimport { safeIter } from \"@ndn/util\";\nimport { pushable } from \"it-pushable\";\nimport { filter, pipeline, tap } from \"streaming-iterables\";\nfunction duplexFromRxTx(rxtx) {\n    return (iterable) => {\n        const rxtxD = rxtx;\n        if (typeof rxtxD.duplex === \"function\") {\n            return rxtxD.duplex(iterable);\n        }\n        const rxtxS = rxtx;\n        rxtxS.tx(iterable);\n        return rxtxS.rx;\n    };\n}\nfunction computeAnnouncement(name, announcement) {\n    switch (typeof announcement) {\n        case \"number\": {\n            return name.getPrefix(announcement);\n        }\n        case \"boolean\": {\n            return announcement ? name : undefined;\n        }\n    }\n    return Name.from(announcement);\n}\nexport class FaceImpl extends EventEmitter {\n    fw;\n    rxtx;\n    attributes;\n    routes = new NameMultiSet();\n    announcements = new NameMultiSet();\n    running = true;\n    txQueue = pushable({ objectMode: true });\n    constructor(fw, rxtx, attributes) {\n        super();\n        this.fw = fw;\n        this.rxtx = rxtx;\n        this.attributes = {\n            local: false,\n            advertiseFrom: true,\n            routeCapture: true,\n            ...rxtx.attributes,\n            ...attributes,\n        };\n        fw.emit(\"faceadd\", this);\n        fw.faces.add(this);\n        void pipeline(() => this.txLoop(), tap((pkt) => fw.emit(\"pkttx\", this, pkt)), duplexFromRxTx(rxtx), tap((pkt) => fw.emit(\"pktrx\", this, pkt)), this.rxLoop);\n        rxtx.on?.(\"up\", this.handleLowerUp);\n        rxtx.on?.(\"down\", this.handleLowerDown);\n    }\n    close() {\n        if (!this.running) {\n            return;\n        }\n        this.running = false;\n        this.rxtx.off?.(\"up\", this.handleLowerUp);\n        this.rxtx.off?.(\"down\", this.handleLowerDown);\n        this.fw.faces.delete(this);\n        for (const [name] of this.routes.multiplicities()) {\n            this.fw.fib.delete(this, name.valueHex);\n        }\n        for (const [name] of this.announcements.multiplicities()) {\n            this.fw.readvertise.removeAnnouncement(this, name);\n        }\n        this.txQueue.end(new Error(\"close\"));\n        this.emit(\"close\");\n        this.fw.emit(\"facerm\", this);\n    }\n    toString() {\n        return this.attributes.describe ?? \"FwFace\";\n    }\n    hasRoute(nameInput) {\n        const name = Name.from(nameInput);\n        return this.routes.count(name) > 0;\n    }\n    addRoute(nameInput, announcement = true) {\n        const name = Name.from(nameInput);\n        this.fw.emit(\"prefixadd\", this, name);\n        if (this.routes.add(name) === 1) {\n            this.fw.fib.insert(this, name.valueHex, this.attributes.routeCapture);\n        }\n        const ann = computeAnnouncement(name, announcement);\n        if (ann) {\n            this.addAnnouncement(ann);\n        }\n    }\n    removeRoute(nameInput, announcement = true) {\n        const name = Name.from(nameInput);\n        const ann = computeAnnouncement(name, announcement);\n        if (ann) {\n            this.removeAnnouncement(ann);\n        }\n        if (this.routes.remove(name) === 0) {\n            this.fw.fib.delete(this, name.valueHex);\n        }\n        this.fw.emit(\"prefixrm\", this, name);\n    }\n    addAnnouncement(nameInput) {\n        if (!this.attributes.advertiseFrom) {\n            return;\n        }\n        const name = Name.from(nameInput);\n        if (this.announcements.add(name) === 1) {\n            this.fw.readvertise.addAnnouncement(this, name);\n        }\n    }\n    removeAnnouncement(nameInput) {\n        if (!this.attributes.advertiseFrom) {\n            return;\n        }\n        const name = Name.from(nameInput);\n        if (this.announcements.remove(name) === 0) {\n            this.fw.readvertise.removeAnnouncement(this, name);\n        }\n    }\n    /** Transmit a packet on the face. */\n    send(pkt) {\n        if (!this.running) {\n            return;\n        }\n        this.txQueue.push(pkt);\n    }\n    handleLowerUp = () => {\n        this.emit(\"up\");\n    };\n    handleLowerDown = () => {\n        this.emit(\"down\");\n    };\n    rxLoop = async (input) => {\n        for await (const pkt of filter(() => this.running, input)) {\n            switch (true) {\n                case pkt.l3 instanceof Interest: {\n                    this.fw[pkt.cancel ? \"cancelInterest\" : \"processInterest\"](this, pkt);\n                    break;\n                }\n                case pkt.l3 instanceof Data: {\n                    this.fw.processData(this, pkt);\n                    break;\n                }\n                case pkt.l3 instanceof Nack: {\n                    this.fw.processNack(this, pkt);\n                    break;\n                }\n            }\n        }\n        this.close();\n    };\n    txLoop() {\n        return safeIter(this.txQueue);\n    }\n}\n","import { __importDefault, __importStar } from \"tslib\";\nimport { lpm } from \"@ndn/packet\";\nimport { assert } from \"@ndn/util\";\nimport _cjsDefaultImport0 from \"mnemonist/default-map.js\"; const DefaultMap = __importDefault(_cjsDefaultImport0).default;\nclass FibEntry {\n    nexthops = new Map(); // face=>capture\n}\nexport class Fib {\n    table = new DefaultMap(() => new FibEntry());\n    insert(face, nameHex, capture) {\n        const entry = this.table.get(nameHex);\n        assert(!entry.nexthops.has(face));\n        entry.nexthops.set(face, capture);\n    }\n    delete(face, nameHex) {\n        const entry = this.table.peek(nameHex);\n        assert(!!entry);\n        entry.nexthops.delete(face);\n        if (entry.nexthops.size === 0) {\n            this.table.delete(nameHex);\n        }\n    }\n    lookup(name) {\n        const result = new Set();\n        for (const entry of lpm(name, (prefixHex) => this.table.peek(prefixHex))) {\n            let capture = false;\n            for (const [nh, c] of entry.nexthops) {\n                result.add(nh);\n                capture ||= c;\n            }\n            if (capture) {\n                break;\n            }\n        }\n        return result;\n    }\n}\n","import { toHex } from \"@ndn/util\";\n/**\n * Name longest prefix match algorithm.\n * @param name target name.\n * @param get callback function to retrieve entry by hexadecimal name prefix.\n */\nexport function* lpm(name, get) {\n    const prefixes = [\"\"];\n    let s = \"\";\n    for (const comp of name.comps) {\n        s += toHex(comp.tlv);\n        prefixes.push(s);\n    }\n    while (prefixes.length > 0) {\n        const prefix = prefixes.pop();\n        const entry = get(prefix);\n        if (entry !== undefined) {\n            yield entry;\n        }\n    }\n}\n","var n=function(n){return 1e3*n[0]+n[1]/1e6},r=function(n){return Number(n.toFixed(2))},e=function(n,e){var t=function(){return r(e())};return t.startedAt=function(){return n},t.seconds=t.s=function(){return r(e()/1e3)},t.milliseconds=t.ms=function(){return r(e())},t.microseconds=t.us=function(){return r(1e3*e())},t.nanoseconds=t.ns=function(){return r(1e6*e())},t},t=\"undefined\"!=typeof process&&process.hrtime?function(){var r=process.hrtime();return e(n(r),function(){return n(process.hrtime(r))})}:\"undefined\"!=typeof window&&window.performance?function(){var n=window.performance.now();return e(n,function(){return window.performance.now()-n})}:function(){var n=Date.now();return e(n,function(){return Date.now()-n})};export{t as default};\n","export var FwPacket;\n(function (FwPacket) {\n    function create(l3, token) {\n        return { l3, token };\n    }\n    FwPacket.create = create;\n    /** Whether this is a plain packet that can be sent on the wire. */\n    function isEncodable({ reject, cancel }) {\n        return !reject && !cancel;\n    }\n    FwPacket.isEncodable = isEncodable;\n})(FwPacket || (FwPacket = {}));\n/** Indicate an Interest has been rejected. */\nexport class RejectInterest {\n    reject;\n    l3;\n    token;\n    constructor(reject, l3, token) {\n        this.reject = reject;\n        this.l3 = l3;\n        this.token = token;\n    }\n}\n/** Request to cancel a pending Interest. */\nexport class CancelInterest {\n    l3;\n    token;\n    constructor(l3, token) {\n        this.l3 = l3;\n        this.token = token;\n    }\n    cancel = true;\n}\n","import { __importDefault, __importStar } from \"tslib\";\nimport { Interest } from \"@ndn/packet\";\nimport hirestime from \"hirestime\";\nimport _cjsDefaultImport0 from \"mnemonist/default-map.js\"; const DefaultMap = __importDefault(_cjsDefaultImport0).default;\nimport { filter, flatMap, pipeline, reduce, tap } from \"streaming-iterables\";\nimport { FwPacket, RejectInterest } from \"./packet_browser.js\";\nconst getNow = hirestime();\n/** Aggregated pending Interests from one or more downstream faces. */\nexport class PitEntry {\n    pit;\n    key;\n    /** Representative Interest. */\n    interest;\n    /** Outgoing numeric PIT token. */\n    token;\n    /** Downstream records. */\n    dnRecords = new DefaultMap(() => ({ nRx: 0, expire: 0, nonce: 0, token: undefined }));\n    /** Last expiration time among downstream. */\n    lastExpire = 0;\n    /** Entry expiration timer; should match this.lastExpire. */\n    expireTimer;\n    constructor(pit, key, interest) {\n        this.pit = pit;\n        this.key = key;\n        this.interest = new Interest(interest);\n    }\n    /** Record Interest from downstream. */\n    receiveInterest(face, { l3: interest, token }) {\n        const now = getNow();\n        const expire = now + interest.lifetime;\n        const nonce = interest.nonce ?? Interest.generateNonce();\n        const dnR = this.dnRecords.get(face);\n        ++dnR.nRx;\n        dnR.expire = expire;\n        dnR.nonce = nonce;\n        dnR.token = token;\n        this.updateExpire(now);\n    }\n    /** Record Interest cancellation from downstream. */\n    cancelInterest(face) {\n        const dnR = this.dnRecords.peek(face);\n        if (!dnR) {\n            return;\n        }\n        this.dnRecords.delete(face);\n        this.updateExpire();\n        face.send(new RejectInterest(\"cancel\", this.interest, dnR.token));\n    }\n    /** Forward Interest to upstream. */\n    forwardInterest(face) {\n        const lifetime = this.lastExpire - getNow();\n        if (lifetime <= 0) {\n            return;\n        }\n        this.interest.lifetime = lifetime;\n        face.send(FwPacket.create(this.interest, this.token));\n    }\n    /** Determine which downstream faces should receive Data from upstream. */\n    *returnData(up) {\n        clearTimeout(this.expireTimer);\n        this.pit.eraseEntry(this);\n        const now = getNow();\n        for (const [dn, { expire, token }] of this.dnRecords) {\n            if (expire > now && dn !== up) {\n                yield { dn, token };\n            }\n        }\n    }\n    updateExpire(now = getNow()) {\n        let lastExpire = 0;\n        for (const { expire } of this.dnRecords.values()) {\n            lastExpire = Math.max(lastExpire, expire);\n        }\n        if (lastExpire <= now) {\n            lastExpire = 0;\n        }\n        if (this.lastExpire === lastExpire) {\n            return;\n        }\n        this.lastExpire = lastExpire;\n        clearTimeout(this.expireTimer);\n        if (this.lastExpire === 0) {\n            this.expire();\n        }\n        else {\n            this.pit.insertEntry(this);\n            this.expireTimer = setTimeout(this.expire, this.lastExpire - now);\n        }\n    }\n    expire = () => {\n        this.pit.eraseEntry(this);\n        for (const [face, { token }] of this.dnRecords) {\n            face.send(new RejectInterest(\"expire\", this.interest, token));\n        }\n    };\n}\n/** Pending Interest table. */\nexport class Pit {\n    dataNoTokenMatch;\n    constructor(dataNoTokenMatch) {\n        this.dataNoTokenMatch = dataNoTokenMatch;\n    }\n    byName = new Map();\n    byToken = new Map();\n    lastToken = 0;\n    generateToken() {\n        do {\n            --this.lastToken;\n            if (this.lastToken <= 0) {\n                this.lastToken = 0xFFFFFFFF;\n            }\n        } while (this.byToken.has(this.lastToken));\n        return this.lastToken;\n    }\n    insertEntry(entry) {\n        this.byName.set(entry.key, entry);\n        entry.token ??= this.generateToken();\n        this.byToken.set(entry.token, entry);\n    }\n    eraseEntry(entry) {\n        this.byName.delete(entry.key);\n        this.byToken.delete(entry.token);\n    }\n    /**\n     * Cancel timers and other I/O resources.\n     * This instance should not be used after this operation.\n     */\n    close() {\n        for (const entry of this.byName.values()) {\n            clearTimeout(entry.expireTimer);\n        }\n    }\n    lookup({ l3: interest }, canInsert = true) {\n        const key = `${interest.name.valueHex} ${interest.canBePrefix ? \"+\" : \"-\"}${interest.mustBeFresh ? \"+\" : \"-\"}`;\n        let entry = this.byName.get(key);\n        if (!entry && canInsert) {\n            entry = new PitEntry(this, key, interest);\n        }\n        return entry;\n    }\n    /**\n     * Satisfy pending Interests with incoming Data.\n     * @returns true if Data satisfies any pending Interest; false if Data is unsolicited.\n     */\n    async satisfy(face, { l3: data, token }) {\n        const nSentData = await pipeline(() => this.findPotentialMatches(data, token), filter(({ interest }) => data.canSatisfy(interest)), flatMap((entry) => entry.returnData(face)), tap(({ dn, token: dnToken }) => dn.send(FwPacket.create(data, dnToken))), reduce((count) => count + 1, 0));\n        return nSentData > 0;\n    }\n    *findPotentialMatches(data, token) {\n        if (typeof token === \"number\") {\n            const entry = this.byToken.get(token);\n            if (entry) {\n                yield entry;\n            }\n            return;\n        }\n        if (!this.dataNoTokenMatch) {\n            return;\n        }\n        let keySuffixes = [\" ++\", \" +-\", \" -+\", \" --\"];\n        for (let prefix = data.name; prefix.length > 0; prefix = prefix.getPrefix(-1)) {\n            const prefixHex = prefix.valueHex;\n            for (const keySuffix of keySuffixes) {\n                const entry = this.byName.get(prefixHex + keySuffix);\n                if (entry) {\n                    yield entry;\n                }\n            }\n            keySuffixes = [\" ++\", \" +-\"];\n        }\n    }\n}\n","import { __importDefault, __importStar } from \"tslib\";\nimport { NameMap, NameMultiMap } from \"@ndn/packet\";\nimport { pushable } from \"it-pushable\";\nimport _cjsDefaultImport0 from \"retry\"; const retry = __importDefault(_cjsDefaultImport0).default;\n/**\n * Manage advertised prefix of the forwarder.\n *\n * This class keeps track of what prefixes are announced by the owning forwarder.\n * It accepts announcements from faces attached to the forwarder, and then informs\n * each destination on what prefixes should be advertised.\n */\nexport class Readvertise {\n    fw;\n    constructor(fw) {\n        this.fw = fw;\n    }\n    announcements = new NameMultiMap();\n    destinations = new Set();\n    addAnnouncement(face, name) {\n        if (this.announcements.add(name, face) > 1) {\n            return;\n        }\n        this.fw.emit(\"annadd\", name);\n        for (const dest of this.destinations) {\n            dest.advertise(name);\n        }\n    }\n    removeAnnouncement(face, name) {\n        if (this.announcements.remove(name, face) > 0) {\n            return;\n        }\n        this.fw.emit(\"annrm\", name);\n        for (const dest of this.destinations) {\n            dest.withdraw(name);\n        }\n    }\n    /**\n     * Cancel timers and other I/O resources.\n     * This instance should not be used after this operation.\n     */\n    close() {\n        for (const dest of this.destinations) {\n            dest.disable();\n        }\n    }\n}\n/**\n * A destination of prefix advertisement.\n *\n * Generally, a prefix advertised to a destination would cause Interests matching the prefix\n * to come to the forwarder, aka prefix registration.\n */\nexport class ReadvertiseDestination {\n    retryOptions;\n    readvertise;\n    table = new NameMap();\n    queue = pushable({ objectMode: true });\n    closed = false;\n    constructor(retryOptions = {\n        forever: true,\n        minTimeout: 5000,\n        maxTimeout: 60000,\n        randomize: true,\n    }) {\n        this.retryOptions = retryOptions;\n    }\n    /** Enable and attach to a forwarder. */\n    enable(fw) {\n        this.readvertise = fw.readvertise;\n        this.readvertise.destinations.add(this);\n        for (const [name] of this.readvertise.announcements.associations()) {\n            this.queue.push(name);\n        }\n        void this.process();\n    }\n    /**\n     * Disable and detach from forwarder.\n     *\n     * Once detached, this instance is no longer usable.\n     */\n    disable() {\n        this.readvertise?.destinations.delete(this);\n        this.readvertise = undefined;\n        for (const [name, record] of this.table) {\n            this.queue.push(name);\n            record.status = ReadvertiseDestination.Status.WITHDRAWING;\n        }\n        this.queue.end();\n        this.closed = true;\n    }\n    /** Set a prefix to be advertised. */\n    advertise(name) {\n        let record = this.table.get(name);\n        if (!record) {\n            record = {\n                status: ReadvertiseDestination.Status.ADVERTISING,\n                state: this.makeState(name),\n            };\n            this.table.set(name, record);\n        }\n        record.status = ReadvertiseDestination.Status.ADVERTISING;\n        this.restart(name, record);\n    }\n    /** Set a prefix to be withdrawn. */\n    withdraw(name) {\n        const record = this.table.get(name);\n        if (!record) {\n            return;\n        }\n        record.status = ReadvertiseDestination.Status.WITHDRAWING;\n        this.restart(name, record);\n    }\n    restart(name, record) {\n        record.retry?.stop();\n        record.retry = retry.operation(this.retryOptions);\n        record.retry.attempt(() => {\n            if (this.closed) {\n                record.retry.stop();\n            }\n            else {\n                this.queue.push(name);\n            }\n        });\n    }\n    async process() {\n        for await (const name of this.queue) {\n            const record = this.table.get(name);\n            if (!record) {\n                continue;\n            }\n            const { status, retry, state } = record;\n            switch (status) {\n                case ReadvertiseDestination.Status.ADVERTISING: {\n                    try {\n                        await this.doAdvertise(name, state);\n                        if (record.status === ReadvertiseDestination.Status.ADVERTISING) {\n                            record.status = ReadvertiseDestination.Status.ADVERTISED;\n                            retry.stop();\n                        }\n                    }\n                    catch (err) {\n                        retry.retry(err);\n                    }\n                    break;\n                }\n                case ReadvertiseDestination.Status.WITHDRAWING: {\n                    try {\n                        await this.doWithdraw(name, state);\n                        if (record.status === ReadvertiseDestination.Status.WITHDRAWING) {\n                            record.status = ReadvertiseDestination.Status.WITHDRAWN;\n                            retry.stop();\n                            this.table.delete(name);\n                        }\n                    }\n                    catch (err) {\n                        retry.retry(err);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    /** Create per-prefix state. */\n    makeState(name) {\n        void name;\n        return {};\n    }\n}\n(function (ReadvertiseDestination) {\n    let Status;\n    (function (Status) {\n        Status[Status[\"ADVERTISING\"] = 0] = \"ADVERTISING\";\n        Status[Status[\"ADVERTISED\"] = 1] = \"ADVERTISED\";\n        Status[Status[\"WITHDRAWING\"] = 2] = \"WITHDRAWING\";\n        Status[Status[\"WITHDRAWN\"] = 3] = \"WITHDRAWN\";\n    })(Status = ReadvertiseDestination.Status || (ReadvertiseDestination.Status = {}));\n})(ReadvertiseDestination || (ReadvertiseDestination = {}));\n","import { EventEmitter } from \"events\";\nimport { FaceImpl } from \"./face_browser.js\";\nimport { Fib } from \"./fib_browser.js\";\nimport { Pit } from \"./pit_browser.js\";\nimport { Readvertise } from \"./readvertise_browser.js\";\nexport var Forwarder;\n(function (Forwarder) {\n    Forwarder.DefaultOptions = {\n        dataNoTokenMatch: true,\n    };\n    /** Create a new forwarding plane. */\n    function create(options) {\n        return new ForwarderImpl({ ...Forwarder.DefaultOptions, ...options });\n    }\n    Forwarder.create = create;\n    let defaultInstance;\n    /** Access the default forwarding plane instance. */\n    function getDefault() {\n        if (!defaultInstance) {\n            defaultInstance = Forwarder.create();\n        }\n        return defaultInstance;\n    }\n    Forwarder.getDefault = getDefault;\n    /** Replace the default forwarding plane instance. */\n    function replaceDefault(fw) {\n        defaultInstance = fw;\n    }\n    Forwarder.replaceDefault = replaceDefault;\n    /** Delete default instance (mainly for unit testing). */\n    function deleteDefault() {\n        if (!defaultInstance) {\n            return;\n        }\n        defaultInstance.close();\n        defaultInstance = undefined;\n    }\n    Forwarder.deleteDefault = deleteDefault;\n})(Forwarder || (Forwarder = {}));\nexport class ForwarderImpl extends EventEmitter {\n    opts;\n    nodeNames = [];\n    faces = new Set();\n    fib = new Fib();\n    pit;\n    readvertise = new Readvertise(this);\n    constructor(opts) {\n        super();\n        this.opts = opts;\n        this.pit = new Pit(opts.dataNoTokenMatch);\n    }\n    addFace(face, attributes = {}) {\n        return new FaceImpl(this, face, attributes);\n    }\n    pickInterestForwardingName(interest) {\n        const fhName = interest.fwHint?.delegations[0];\n        if (fhName && this.nodeNames.every((nodeName) => !fhName.isPrefixOf(nodeName))) {\n            return fhName;\n        }\n        return interest.name;\n    }\n    /** Process incoming Interest. */\n    processInterest(face, pkt) {\n        const pi = this.pit.lookup(pkt);\n        pi.receiveInterest(face, pkt);\n        const fwName = this.pickInterestForwardingName(pkt.l3);\n        for (const nh of this.fib.lookup(fwName)) {\n            if (nh !== face) {\n                pi.forwardInterest(nh);\n            }\n        }\n    }\n    /** Process incoming cancel Interest request. */\n    cancelInterest(face, pkt) {\n        const pi = this.pit.lookup(pkt, false);\n        pi?.cancelInterest(face);\n    }\n    /** Process incoming Data. */\n    processData(face, pkt) {\n        void this.pit.satisfy(face, pkt);\n    }\n    /** Process incoming Nack. */\n    processNack(face, nack) {\n        // ignore Nack\n        void face;\n        void nack;\n    }\n    close() {\n        this.pit.close();\n        this.readvertise.close();\n        for (const face of this.faces) {\n            face.close();\n        }\n    }\n}\n","import { randomJitter } from \"@ndn/util\";\n/** Construct RetxGenerator from RetxPolicy. */\nexport function makeRetxGenerator(policy) {\n    if (!policy) {\n        return () => [];\n    }\n    if (typeof policy === \"number\") {\n        return makeRetxGenerator({ limit: policy });\n    }\n    if (typeof policy === \"function\") {\n        return policy;\n    }\n    return function* (interestLifetime) {\n        const { limit = 0, interval = interestLifetime * 0.5, randomize = 0.1, backoff = 1, max = interestLifetime * 0.9, } = policy;\n        const jitter = randomJitter(randomize);\n        let nextInterval = interval;\n        for (let i = 0; i < limit; ++i) {\n            yield nextInterval * jitter();\n            nextInterval = Math.min(nextInterval * backoff, max);\n        }\n    };\n}\n","/**\n * Create a random jitter generator function.\n * @param r jitter factor around 1.\n * @param x median value.\n * @returns jitter generator function.\n *\n * randomJitter(0.1, 2) generates random values within [1.8, 2.2].\n */\nexport function randomJitter(r, x = 1) {\n    r = Math.max(0, Math.min(r, 1));\n    const min = 1 - r;\n    const distance = 2 * r;\n    return () => x * (min + distance * Math.random());\n}\nfunction timeoutAbortSignalFallback(time) {\n    // Node.js 16.x lacks global DOMException, but it has AbortSignal.timeout so this fallback won't\n    // be called. As of 20220601, this fallback is needed for Chrome, etc.\n    const abort = new AbortController();\n    setTimeout(() => abort.abort(new DOMException(\"TimeoutError\", \"TimeoutError\")), time);\n    return abort.signal;\n}\n/** AbortSignal.timeout ponyfill. */\nexport const timeoutAbortSignal = AbortSignal.timeout ?? timeoutAbortSignalFallback;\n","import { __importDefault, __importStar } from \"tslib\";\nimport { Forwarder } from \"@ndn/fw\";\nimport _cjsDefaultImport0 from \"applymixins\"; const applyMixins = __importDefault(_cjsDefaultImport0).default;\nimport { EndpointConsumer } from \"./consumer_browser.js\";\nimport { EndpointProducer } from \"./producer_browser.js\";\n/**\n * Endpoint is the main entry point for an application to interact with the forwarding plane.\n * It provides basic consumer and producer functionality.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class Endpoint {\n    opts;\n    fw;\n    constructor(opts = {}) {\n        this.opts = opts;\n        this.fw = opts.fw ?? Forwarder.getDefault();\n    }\n}\napplyMixins(Endpoint, [EndpointConsumer, EndpointProducer]);\n(function (Endpoint) {\n    /** Delete default Forwarder instance (mainly for unit testing). */\n    Endpoint.deleteDefaultForwarder = Forwarder.deleteDefault;\n})(Endpoint || (Endpoint = {}));\n","import { CancelInterest, FwPacket } from \"@ndn/fw\";\nimport { Data, Interest } from \"@ndn/packet\";\nimport { pushable } from \"it-pushable\";\nimport { makeRetxGenerator } from \"./retx_browser.js\";\n/** Consumer functionality of Endpoint. */\nexport class EndpointConsumer {\n    /** Consume a single piece of Data. */\n    consume(interestInput, opts = {}) {\n        const interest = interestInput instanceof Interest ? interestInput : new Interest(interestInput);\n        const { describe = `consume(${interest.name})`, signal, modifyInterest, retx, verifier, } = { ...this.opts, ...opts };\n        Interest.makeModifyFunc(modifyInterest)(interest);\n        let nRetx = -1;\n        const retxGen = makeRetxGenerator(retx)(interest.lifetime)[Symbol.iterator]();\n        const promise = new Promise((resolve, reject) => {\n            const rx = pushable({ objectMode: true });\n            let timer;\n            const cancelRetx = () => {\n                clearTimeout(timer);\n                timer = undefined;\n            };\n            const sendInterest = () => {\n                cancelRetx();\n                const { value, done } = retxGen.next();\n                if (!done) {\n                    timer = setTimeout(sendInterest, value);\n                }\n                rx.push(FwPacket.create(interest));\n                ++nRetx;\n            };\n            const onAbort = () => {\n                cancelRetx();\n                rx.push(new CancelInterest(interest));\n            };\n            signal?.addEventListener(\"abort\", onAbort);\n            this.fw.addFace({\n                rx,\n                async tx(iterable) {\n                    for await (const pkt of iterable) {\n                        if (pkt.l3 instanceof Data) {\n                            try {\n                                await verifier?.verify(pkt.l3);\n                            }\n                            catch (err) {\n                                reject(new Error(`Data verify failed: ${err} @${describe}`));\n                                break;\n                            }\n                            resolve(pkt.l3);\n                            break;\n                        }\n                        if (pkt.reject && !timer) {\n                            reject(new Error(`Interest rejected: ${pkt.reject} @${describe}`));\n                            break;\n                        }\n                    }\n                    cancelRetx();\n                    signal?.removeEventListener(\"abort\", onAbort);\n                    rx.end();\n                },\n            }, {\n                describe,\n                local: true,\n            });\n            sendInterest();\n        });\n        return Object.defineProperties(promise, {\n            interest: { value: interest },\n            nRetx: { get() { return nRetx; } },\n        });\n    }\n}\n","import { FwPacket } from \"@ndn/fw\";\nimport { Data, Interest, Name, SigType } from \"@ndn/packet\";\nimport { flatTransform } from \"streaming-iterables\";\n/** Producer functionality of Endpoint. */\nexport class EndpointProducer {\n    /**\n     * Start a producer.\n     * @param prefixInput prefix registration; if undefined, prefixes may be added later.\n     * @param handler function to handle incoming Interest.\n     */\n    produce(prefixInput, handler, opts = {}) {\n        const prefix = prefixInput === undefined ? undefined : new Name(prefixInput);\n        const { describe = `produce(${prefix})`, signal, routeCapture = true, announcement, concurrency = 1, dataSigner, dataBuffer, autoBuffer = true, } = { ...this.opts, ...opts };\n        let producer; // eslint-disable-line prefer-const\n        const processInterestUnbuffered = async (interest) => {\n            const data = await handler(interest, producer);\n            if (!(data instanceof Data)) {\n                return undefined;\n            }\n            await signUnsignedData(data, dataSigner);\n            if (!await data.canSatisfy(interest)) {\n                return undefined;\n            }\n            return data;\n        };\n        let processInterest = processInterestUnbuffered;\n        if (dataBuffer) {\n            processInterest = async (interest) => {\n                let found = await dataBuffer.find(interest);\n                if (!found) {\n                    const output = await processInterestUnbuffered(interest);\n                    if (output) {\n                        if (autoBuffer) {\n                            await dataBuffer.insert(output);\n                        }\n                        return output;\n                    }\n                    found = await dataBuffer.find(interest);\n                }\n                return found;\n            };\n        }\n        const face = this.fw.addFace({\n            duplex: flatTransform(concurrency, async function* ({ l3: interest, token }) {\n                if (!(interest instanceof Interest)) {\n                    return;\n                }\n                const data = await processInterest(interest).catch(() => undefined);\n                if (!data) {\n                    return;\n                }\n                yield FwPacket.create(data, token);\n            }),\n        }, {\n            describe,\n            local: true,\n            routeCapture,\n        });\n        if (prefix) {\n            face.addRoute(prefix, announcement);\n        }\n        const onAbort = () => {\n            face.close();\n            signal?.removeEventListener(\"abort\", onAbort);\n        };\n        signal?.addEventListener(\"abort\", onAbort);\n        producer = {\n            prefix,\n            face,\n            dataBuffer,\n            processInterest,\n            close: onAbort,\n        };\n        return producer;\n    }\n}\nexport async function signUnsignedData(data, dataSigner) {\n    if (dataSigner && data.sigInfo.type === SigType.Null) {\n        await dataSigner.sign(data);\n    }\n}\n","import { TT } from \"../an_browser.js\";\nimport { Component } from \"./component_browser.js\";\nimport { ImplicitDigest, ParamsDigest } from \"./digest-comp_browser.js\";\nimport { Name } from \"./name_browser.js\";\n/**\n * Functions to print and parse names in alternate/pretty URI syntax.\n *\n * This class is constructed with a sequence of NamingConventions. Each component is matched\n * against these conventions in order, and the first matching convention can determine how to\n * print that component in an alternate URI syntax, if available.\n *\n * Other than pre-constructed 'AltUri' instances exported by this and naming convention packages,\n * you may construct an instance with only the naming conventions you have adopted, so that a\n * component that happens to match a convention that your application did not adopt is not\n * mistakenly interpreted with that convention.\n */\nexport class AltUriConverter {\n    conventions;\n    constructor(conventions) {\n        this.conventions = conventions;\n    }\n    /** Print component in alternate URI syntax */\n    ofComponent = (comp) => {\n        for (const conv of this.conventions) {\n            if (conv.match(comp)) {\n                return conv.toAltUri(comp);\n            }\n        }\n        return comp.toString();\n    };\n    /** Print name in alternate URI syntax. */\n    ofName = (name) => `/${name.comps.map((comp) => this.ofComponent(comp)).join(\"/\")}`;\n    /** Parse component from alternate URI syntax */\n    parseComponent = (input) => {\n        for (const conv of this.conventions) {\n            const comp = conv.fromAltUri(input);\n            if (comp) {\n                return comp;\n            }\n        }\n        return Component.from(input);\n    };\n    /** Parse name from alternate URI syntax. */\n    parseName = (input) => new Name(input, this.parseComponent);\n}\nclass Generic {\n    match({ type }) { return type === TT.GenericNameComponent; }\n    create() { /* c8 ignore next */ throw new TypeError(\"not supported\"); }\n    parse() { /* c8 ignore next */ throw new TypeError(\"not supported\"); }\n    toAltUri(comp) { return comp.toString().slice(2); }\n    fromAltUri() { return undefined; }\n}\n/** Print Generic, ImplicitDigest, ParamsDigest in alternate URI syntax. */\nexport const AltUri = new AltUriConverter([\n    new Generic(),\n    ImplicitDigest,\n    ParamsDigest,\n]);\n","const DEFAULT_MTU = 1200;\n/**\n * Low-level transport.\n *\n * The transport understands NDN TLV structures, but does not otherwise concern with packet format.\n */\nexport class Transport {\n    attributes;\n    constructor(attributes) {\n        this.attributes = attributes;\n    }\n    /**\n     * Return the transport MTU, if known.\n     * The transport should be able to send TLV structure of up to this size.\n     */\n    get mtu() { return DEFAULT_MTU; }\n    /**\n     * Reopen the transport after it has failed.\n     * @returns the same transport or a new transport after it has been reconnected.\n     */\n    reopen() {\n        return Promise.reject(new Transport.ReopenNotSupportedError());\n    }\n    toString() {\n        /* c8 ignore next */\n        return this.attributes.describe ?? this.constructor.name;\n    }\n}\n(function (Transport) {\n    /**\n     * Error thrown by transport.reopen() to indicate that reopen operation is not supported.\n     * No further reopen() will be attempted.\n     */\n    class ReopenNotSupportedError extends Error {\n        constructor() {\n            super(\"reopen not supported\");\n        }\n    }\n    Transport.ReopenNotSupportedError = ReopenNotSupportedError;\n})(Transport || (Transport = {}));\n","import { TT as l3TT } from \"@ndn/packet\";\nexport const TT = {\n    LpPacket: 0x64,\n    LpPayload: 0x50,\n    LpSeqNum: 0x51,\n    FragIndex: 0x52,\n    FragCount: 0x53,\n    PitToken: 0x62,\n    Nack: l3TT.Nack,\n    NackReason: l3TT.NackReason,\n    CongestionMark: 0x0340,\n};\n","import { NackHeader } from \"@ndn/packet\";\nimport { Encoder, EvDecoder, NNI } from \"@ndn/tlv\";\nimport { asDataView } from \"@ndn/util\";\nimport { TT } from \"./an_browser.js\";\nfunction isCritical(tt) {\n    return !(tt >= 800 && tt <= 959 && tt % 4 === 0);\n}\nconst EVD = new EvDecoder(\"LpPacket\", TT.LpPacket)\n    .setIsCritical(isCritical)\n    .add(TT.LpSeqNum, (t, { value }) => t.fragSeqNum = asDataView(value).getBigUint64(0))\n    .add(TT.FragIndex, (t, { nni }) => t.fragIndex = nni)\n    .add(TT.FragCount, (t, { nni }) => t.fragCount = nni)\n    .add(TT.PitToken, (t, { value }) => t.pitToken = value)\n    .add(TT.Nack, (t, { decoder }) => t.nack = decoder.decode(NackHeader))\n    .add(TT.LpPayload, (t, { value }) => t.payload = value);\n/** NDNLPv2 packet. */\nexport class LpPacket {\n    static decodeFrom(decoder) {\n        return EVD.decode(new LpPacket(), decoder);\n    }\n    fragSeqNum;\n    fragIndex = 0;\n    fragCount = 1;\n    pitToken;\n    nack;\n    payload;\n    encodeTo(encoder) {\n        encoder.prependTlv(TT.LpPacket, this.fragSeqNum !== undefined && [TT.LpSeqNum, NNI(this.fragSeqNum, { len: 8 })], this.fragIndex > 0 && [TT.FragIndex, NNI(this.fragIndex)], this.fragCount > 1 && [TT.FragCount, NNI(this.fragCount)], ...this.encodeL3Headers(), [TT.LpPayload, Encoder.OmitEmpty, this.payload]);\n    }\n    encodeL3Headers() {\n        return [\n            [TT.PitToken, Encoder.OmitEmpty, this.pitToken],\n            this.nack,\n        ];\n    }\n    copyL3HeadersFrom(src) {\n        this.pitToken = src.pitToken;\n        this.nack = src.nack;\n    }\n}\n","import { Encoder } from \"@ndn/tlv\";\nimport { LpPacket } from \"./packet_browser.js\";\nclass SeqNumGen {\n    current = (BigInt(Math.trunc(Math.random() * 0x100000000)) << 32n) |\n        BigInt(Math.trunc(Math.random() * 0x100000000));\n    next() {\n        this.current = BigInt.asUintN(64, this.current + 1n);\n        return this.current;\n    }\n}\nconst OVERHEAD = 0 +\n    1 + 3 + // LpPacket TL\n    1 + 1 + 8 + // LpSeqNum\n    1 + 1 + 2 + // FragIndex\n    1 + 1 + 2 + // FragCount\n    1 + 3 + // LpPayload TL\n    0;\n/** NDNLPv2 fragmenter. */\nexport class Fragmenter {\n    seqNumGen = new SeqNumGen();\n    /**\n     * Fragment a packet.\n     * @returns a sequence of fragments, or empty array if fragmentation fails.\n     */\n    fragment(full, mtu) {\n        const fragmentRoom = mtu - OVERHEAD;\n        const sizeofL3Headers = Encoder.encode(full.encodeL3Headers()).length;\n        const sizeofPayload = full.payload?.byteLength ?? 0;\n        const sizeofFirstFragment = Math.min(sizeofPayload, fragmentRoom - sizeofL3Headers);\n        if (sizeofFirstFragment === sizeofPayload) { // no fragmentation necessary\n            return [full];\n        }\n        if (sizeofFirstFragment <= 0) { // MTU is too small for L3 headers, drop the packet\n            return [];\n        }\n        const fragments = [];\n        const first = new LpPacket();\n        first.copyL3HeadersFrom(full);\n        first.fragSeqNum = this.seqNumGen.next();\n        first.payload = full.payload.subarray(0, sizeofFirstFragment);\n        fragments.push(first);\n        for (let offset = sizeofFirstFragment; offset < sizeofPayload; offset += fragmentRoom) {\n            const fragment = new LpPacket();\n            fragment.fragSeqNum = this.seqNumGen.next();\n            fragment.fragIndex = fragments.length;\n            fragment.payload = full.payload.subarray(offset, offset + fragmentRoom);\n            fragments.push(fragment);\n        }\n        for (const fragment of fragments) {\n            fragment.fragCount = fragments.length;\n        }\n        return fragments;\n    }\n}\n","import { concatBuffers } from \"@ndn/util\";\nimport { LpPacket } from \"./packet_browser.js\";\nclass PartialPacket {\n    seqNumBase;\n    constructor(seqNumBase) {\n        this.seqNumBase = seqNumBase;\n    }\n    buffer = [];\n    accepted = 0;\n    payloadLength = 0;\n    accept(fragment) {\n        if (this.accepted === 0) { // first\n            this.buffer.length = fragment.fragCount;\n            this.acceptOne(fragment);\n            return undefined;\n        }\n        if (fragment.fragCount !== this.buffer.length) { // mismatch\n            return false;\n        }\n        if (this.buffer[fragment.fragIndex]) { // duplicate\n            return undefined;\n        }\n        this.acceptOne(fragment);\n        if (this.accepted === this.buffer.length) {\n            return this.reassemble();\n        }\n        return undefined;\n    }\n    acceptOne(fragment) {\n        this.buffer[fragment.fragIndex] = fragment;\n        ++this.accepted;\n        this.payloadLength += fragment.payload?.length ?? 0;\n    }\n    reassemble() {\n        const full = new LpPacket();\n        full.copyL3HeadersFrom(this.buffer[0]);\n        const parts = [];\n        for (const fragment of this.buffer) {\n            const part = fragment?.payload;\n            if (part) {\n                parts.push(part);\n            }\n        }\n        full.payload = concatBuffers(parts, this.payloadLength);\n        return full;\n    }\n}\n/** NDNLPv2 reassembler. */\nexport class Reassembler {\n    capacity;\n    constructor(capacity) {\n        this.capacity = capacity;\n    }\n    partials = new Map();\n    /**\n     * Process a fragment.\n     * @returns fully reassembled packet, or undefined if packet is not yet complete.\n     */\n    accept(fragment) {\n        if (fragment.fragCount === 1) { // not fragmented\n            return fragment;\n        }\n        if (fragment.fragSeqNum === undefined ||\n            fragment.fragIndex >= fragment.fragCount) { // bad fragment\n            return undefined;\n        }\n        const seqNumBase = BigInt.asUintN(64, fragment.fragSeqNum - BigInt(fragment.fragIndex));\n        const partial = this.getPartial(seqNumBase);\n        const result = partial.accept(fragment);\n        if (result) {\n            return result;\n        }\n        if (result !== false) {\n            this.putPartial(partial);\n        }\n        return undefined;\n    }\n    getPartial(seqNumBase) {\n        const partial = this.partials.get(seqNumBase);\n        if (partial) {\n            this.partials.delete(seqNumBase);\n            return partial;\n        }\n        return new PartialPacket(seqNumBase);\n    }\n    putPartial(partial) {\n        this.partials.set(partial.seqNumBase, partial);\n        if (this.partials.size > this.capacity) { // exceed capacity, delete oldest\n            // eslint-disable-next-line no-unreachable-loop\n            for (const key of this.partials.keys()) {\n                this.partials.delete(key);\n                break;\n            }\n        }\n    }\n}\n","import { __importDefault, __importStar } from \"tslib\";\nimport { Data, Interest, Nack, TT as l3TT } from \"@ndn/packet\";\nimport { Decoder, Encoder, printTT } from \"@ndn/tlv\";\nimport { assert, flatMapOnce, toHex } from \"@ndn/util\";\nimport _cjsDefaultImport0 from \"it-keepalive\"; const itKeepAlive = __importDefault(_cjsDefaultImport0).default;\nimport { TT } from \"./an_browser.js\";\nimport { Fragmenter } from \"./fragmenter_browser.js\";\nimport { LpPacket } from \"./packet_browser.js\";\nimport { Reassembler } from \"./reassembler_browser.js\";\nconst IDLE = Encoder.encode(new LpPacket());\n/** NDNLPv2 service. */\nexport class LpService {\n    transport;\n    constructor({ keepAlive = 60000, mtu = Infinity, reassemblerCapacity = 16, }, transport) {\n        this.transport = transport;\n        if (Number.isFinite(keepAlive) && keepAlive > 0) {\n            this.keepAlive = Math.ceil(keepAlive);\n        }\n        this.mtu = mtu;\n        this.reassembler = new Reassembler(reassemblerCapacity);\n    }\n    keepAlive;\n    mtu;\n    fragmenter = new Fragmenter();\n    reassembler;\n    rx = (iterable) => flatMapOnce((tlv) => this.decode(tlv), iterable);\n    *decode(dtlv) {\n        const { type, decoder, tlv } = dtlv;\n        try {\n            if (type !== TT.LpPacket) {\n                yield this.decodeL3(dtlv);\n                return;\n            }\n            const fragment = decoder.decode(LpPacket);\n            const lpp = this.reassembler.accept(fragment);\n            if (!lpp?.payload) {\n                return;\n            }\n            const l3pkt = this.decodeL3(new Decoder(lpp.payload).read());\n            if (lpp.nack) {\n                if (l3pkt.l3 instanceof Interest) {\n                    l3pkt.l3 = new Nack(l3pkt.l3, lpp.nack);\n                }\n                else {\n                    throw new Error(\"Nack can only appear on Interest\");\n                }\n            }\n            l3pkt.token = lpp.pitToken;\n            yield l3pkt;\n        }\n        catch (err) {\n            yield new LpService.RxError(err, tlv);\n        }\n    }\n    decodeL3({ type, decoder }) {\n        switch (type) {\n            case l3TT.Interest: {\n                return { l3: decoder.decode(Interest) };\n            }\n            case l3TT.Data: {\n                return { l3: decoder.decode(Data) };\n            }\n            default: {\n                throw new Error(`unrecognized TLV-TYPE ${printTT(type)} as L3Pkt`);\n            }\n        }\n    }\n    tx = (iterable) => flatMapOnce((pkt) => this.encode(pkt), this.keepAlive ?\n        itKeepAlive(() => false, { timeout: this.keepAlive })(iterable) :\n        iterable);\n    *encode(pkt) {\n        if (pkt === false) {\n            yield IDLE;\n            return;\n        }\n        const mtu = Math.min(this.mtu, this.transport.mtu);\n        const { l3, token } = pkt;\n        const lpp = new LpPacket();\n        lpp.pitToken = token;\n        try {\n            if (l3 instanceof Interest || l3 instanceof Data) {\n                const payload = Encoder.encode(l3);\n                if (!token && payload.length <= mtu) {\n                    return yield payload;\n                }\n                lpp.payload = payload;\n            }\n            else {\n                assert(l3 instanceof Nack);\n                lpp.nack = l3.header;\n                lpp.payload = Encoder.encode(l3.interest);\n            }\n        }\n        catch (err) {\n            return yield new LpService.TxError(err, l3);\n        }\n        if (Number.isFinite(mtu)) {\n            yield* this.fragmenter.fragment(lpp, mtu).map((fragment) => Encoder.encode(fragment, mtu));\n        }\n        else {\n            yield Encoder.encode(lpp);\n        }\n    }\n}\n(function (LpService) {\n    class RxError extends Error {\n        packet;\n        constructor(inner, packet) {\n            super(`${inner.message} ${toHex(packet)}`);\n            this.packet = packet;\n        }\n    }\n    LpService.RxError = RxError;\n    class TxError extends Error {\n        packet;\n        constructor(inner, packet) {\n            super(`${inner.message} ${packet instanceof Nack ? packet.interest.name : packet.name}`);\n            this.packet = packet;\n        }\n    }\n    LpService.TxError = TxError;\n})(LpService || (LpService = {}));\n","export class AbortError extends Error {\n    constructor(message, code) {\n        super(message ?? 'The operation was aborted');\n        this.type = 'aborted';\n        this.code = code ?? 'ABORT_ERR';\n    }\n}\n//# sourceMappingURL=abort-error.js.map","import { AbortError } from './abort-error.js';\nimport { getIterator } from 'get-iterator';\n// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\nexport function abortableSource(source, signal, options) {\n    const opts = options ?? {};\n    const iterator = getIterator(source);\n    async function* abortable() {\n        let nextAbortHandler;\n        const abortHandler = () => {\n            if (nextAbortHandler != null)\n                nextAbortHandler();\n        };\n        signal.addEventListener('abort', abortHandler);\n        while (true) {\n            let result;\n            try {\n                if (signal.aborted) {\n                    const { abortMessage, abortCode } = opts;\n                    throw new AbortError(abortMessage, abortCode);\n                }\n                const abort = new Promise((resolve, reject) => {\n                    nextAbortHandler = () => {\n                        const { abortMessage, abortCode } = opts;\n                        reject(new AbortError(abortMessage, abortCode));\n                    };\n                });\n                // Race the iterator and the abort signals\n                result = await Promise.race([abort, iterator.next()]);\n                nextAbortHandler = null;\n            }\n            catch (err) {\n                signal.removeEventListener('abort', abortHandler);\n                // Might not have been aborted by a known signal\n                const isKnownAborter = err.type === 'aborted' && signal.aborted;\n                if (isKnownAborter && (opts.onAbort != null)) {\n                    // Do any custom abort handling for the iterator\n                    await opts.onAbort(source);\n                }\n                // End the iterator if it is a generator\n                if (typeof iterator.return === 'function') {\n                    try {\n                        const p = iterator.return();\n                        if (p instanceof Promise) { // eslint-disable-line max-depth\n                            p.catch(err => {\n                                if (opts.onReturnError != null) {\n                                    opts.onReturnError(err);\n                                }\n                            });\n                        }\n                    }\n                    catch (err) {\n                        if (opts.onReturnError != null) { // eslint-disable-line max-depth\n                            opts.onReturnError(err);\n                        }\n                    }\n                }\n                if (isKnownAborter && opts.returnOnAbort === true) {\n                    return;\n                }\n                throw err;\n            }\n            if (result.done === true) {\n                break;\n            }\n            yield result.value;\n        }\n        signal.removeEventListener('abort', abortHandler);\n    }\n    return abortable();\n}\nexport function abortableSink(sink, signal, options) {\n    return (source) => sink(abortableSource(source, signal, options));\n}\nexport function abortableDuplex(duplex, signal, options) {\n    return {\n        sink: abortableSink(duplex.sink, signal, {\n            ...options,\n            onAbort: undefined\n        }),\n        source: abortableSource(duplex.source, signal, options)\n    };\n}\nexport { AbortError };\nexport { abortableSink as abortableTransform };\n//# sourceMappingURL=index.js.map","export function getIterator(obj) {\n    if (obj != null) {\n        if (typeof obj[Symbol.iterator] === 'function') {\n            return obj[Symbol.iterator]();\n        }\n        if (typeof obj[Symbol.asyncIterator] === 'function') {\n            return obj[Symbol.asyncIterator]();\n        }\n        if (typeof obj.next === 'function') {\n            return obj; // probably an iterator\n        }\n    }\n    throw new Error('argument is not an iterator or iterable');\n}\n//# sourceMappingURL=index.js.map","import { __importDefault, __importStar } from \"tslib\";\nimport { EventEmitter } from \"events\";\nimport { Forwarder, FwPacket } from \"@ndn/fw\";\nimport { LpService } from \"@ndn/lp\";\nimport { Interest } from \"@ndn/packet\";\nimport { asDataView } from \"@ndn/util\";\nimport { abortableSource, AbortError as IteratorAbortError } from \"abortable-iterator\";\nimport { pushable } from \"it-pushable\";\nimport _cjsDefaultImport0 from \"retry\"; const retry = __importDefault(_cjsDefaultImport0).default;\nimport { consume, filter, map, pipeline } from \"streaming-iterables\";\nimport { Transport } from \"./transport_browser.js\";\n/** Network layer face for sending and receiving L3 packets. */\nexport class L3Face extends EventEmitter {\n    transport;\n    attributes;\n    lp;\n    rx;\n    wireTokenPrefix = Math.trunc(Math.random() * 0x10000);\n    get state() { return this.state_; }\n    set state(newState) {\n        if (newState === this.state_) {\n            return;\n        }\n        this.state_ = newState;\n        this.emit(\"state\", newState);\n        switch (newState) {\n            case L3Face.State.UP: {\n                this.emit(\"up\");\n                break;\n            }\n            case L3Face.State.DOWN: {\n                const err = this.lastError instanceof Error ?\n                    this.lastError :\n                    new Error(`${this.lastError ?? \"unknown error\"}`);\n                this.emit(\"down\", err);\n                this.lastError = undefined;\n                break;\n            }\n            case L3Face.State.CLOSED: {\n                this.emit(\"close\");\n                break;\n            }\n        }\n    }\n    state_ = L3Face.State.UP;\n    lastError;\n    rxSources = pushable({ objectMode: true });\n    reopenRetry;\n    constructor(transport, attributes = {}, lpOptions = {}) {\n        super();\n        this.transport = transport;\n        this.attributes = {\n            describe: `L3Face(${transport})`,\n            advertiseFrom: false,\n            ...transport.attributes,\n            ...attributes,\n        };\n        this.lp = new LpService(lpOptions, transport);\n        this.rx = this.makeRx();\n    }\n    async *makeRx() {\n        for await (const source of this.rxSources) {\n            try {\n                yield* this.rxTransform(source);\n                this.lastError = new Error(\"RX ending\");\n                this.state = L3Face.State.DOWN;\n            }\n            catch (err) {\n                if (!(err instanceof IteratorAbortError)) {\n                    this.lastError = err;\n                    this.state = L3Face.State.DOWN;\n                }\n            }\n        }\n    }\n    async *rxTransform(transportRx) {\n        yield* pipeline(() => transportRx, this.lp.rx, filter((pkt) => {\n            if (pkt instanceof LpService.RxError) {\n                this.emit(\"rxerror\", pkt);\n                return false;\n            }\n            return true;\n        }), map(({ l3, token: wireToken }) => {\n            let internalToken;\n            if (l3 instanceof Interest) {\n                internalToken = wireToken;\n            }\n            else if (wireToken?.length === 6) {\n                const dv = asDataView(wireToken);\n                if (dv.getUint16(0) === this.wireTokenPrefix) {\n                    internalToken = dv.getUint32(2);\n                }\n            }\n            return FwPacket.create(l3, internalToken);\n        }));\n    }\n    txTransform(fwTx) {\n        return pipeline(() => fwTx, filter((pkt) => FwPacket.isEncodable(pkt)), map(({ l3, token: internalToken }) => {\n            let wireToken;\n            if (typeof internalToken === \"number\") {\n                wireToken = new Uint8Array(6);\n                const dv = asDataView(wireToken);\n                dv.setUint16(0, this.wireTokenPrefix);\n                dv.setUint32(2, internalToken);\n            }\n            else if (internalToken instanceof Uint8Array) {\n                wireToken = internalToken;\n            }\n            return { l3, token: wireToken };\n        }), this.lp.tx, filter((value) => {\n            if (value instanceof LpService.TxError) {\n                this.emit(\"txerror\", value);\n                return false;\n            }\n            return true;\n        }));\n    }\n    tx = async (iterable) => {\n        const txSourceIterator = this.txTransform(iterable)[Symbol.asyncIterator]();\n        const txSourceIterable = {\n            [Symbol.asyncIterator]: () => ({\n                next: () => txSourceIterator.next(),\n            }),\n        };\n        while (this.state !== L3Face.State.CLOSED) {\n            if (this.state === L3Face.State.DOWN) {\n                this.reopenTransport();\n            }\n            const abort = new AbortController();\n            const handleStateChange = () => abort.abort();\n            this.once(\"state\", handleStateChange);\n            try {\n                const txSource = abortableSource(txSourceIterable, abort.signal);\n                if (this.state === L3Face.State.UP) {\n                    this.rxSources.push(abortableSource(this.transport.rx, abort.signal));\n                    await this.transport.tx(txSource);\n                }\n                else {\n                    await consume(txSource);\n                }\n                this.state = L3Face.State.CLOSED;\n            }\n            catch (err) {\n                if (!(err instanceof IteratorAbortError)) {\n                    this.lastError = err;\n                    this.state = L3Face.State.DOWN;\n                }\n            }\n            finally {\n                abort.abort();\n                this.off(\"state\", handleStateChange);\n            }\n        }\n        this.reopenRetry?.stop();\n        this.rxSources.end();\n    };\n    reopenTransport() {\n        this.reopenRetry?.stop();\n        this.reopenRetry = retry.operation({\n            forever: true,\n            minTimeout: 100,\n            maxTimeout: 60000,\n            randomize: true,\n        });\n        this.reopenRetry.attempt(async () => {\n            try {\n                this.transport = await this.transport.reopen();\n            }\n            catch (err) {\n                if (!(err instanceof Transport.ReopenNotSupportedError)) {\n                    this.reopenRetry.retry(err);\n                }\n                return;\n            }\n            if (this.state === L3Face.State.CLOSED) {\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\n                void this.transport.tx((async function* () { })()); // shutdown transport\n                return;\n            }\n            this.reopenRetry.stop();\n            this.state = L3Face.State.UP;\n        });\n    }\n}\n(function (L3Face) {\n    let State;\n    (function (State) {\n        State[State[\"UP\"] = 0] = \"UP\";\n        State[State[\"DOWN\"] = 1] = \"DOWN\";\n        State[State[\"CLOSED\"] = 2] = \"CLOSED\";\n    })(State = L3Face.State || (L3Face.State = {}));\n    function makeCreateFace(createTransport) {\n        return (async (opts, ...args) => {\n            const created = await createTransport(...args);\n            const { fw = Forwarder.getDefault(), addRoutes, l3, lp, callback, } = opts;\n            const makeFace = (transport) => {\n                const l3face = new L3Face(transport, { advertiseFrom: false, ...l3 }, lp);\n                const fwFace = fw.addFace(l3face);\n                processAddRoutes(fwFace, addRoutes);\n                callback?.(transport, l3face, fwFace);\n                return fwFace;\n            };\n            return Array.isArray(created) ? created.map(makeFace) : makeFace(created);\n        });\n    }\n    L3Face.makeCreateFace = makeCreateFace;\n    function processAddRoutes(fwFace, addRoutes = [\"/\"]) {\n        for (const routeName of addRoutes) {\n            fwFace.addRoute(routeName);\n        }\n    }\n    L3Face.processAddRoutes = processAddRoutes;\n})(L3Face || (L3Face = {}));\n","import { __importDefault, __importStar } from \"tslib\";\nimport { L3Face, rxFromPacketIterable, Transport } from \"@ndn/l3face\";\nimport _cjsDefaultImport0 from \"event-iterator\"; const EventIterator = __importDefault(_cjsDefaultImport0).default;\nimport { makeWebSocket } from \"./ws_browser.js\";\n/** WebSocket transport. */\nexport class WsTransport extends Transport {\n    sock;\n    opts;\n    rx;\n    highWaterMark;\n    lowWaterMark;\n    constructor(sock, opts) {\n        super({ describe: `WebSocket(${sock.url})` });\n        this.sock = sock;\n        this.opts = opts;\n        sock.binaryType = \"arraybuffer\";\n        this.rx = rxFromPacketIterable(new EventIterator(({ push, stop }) => {\n            const handleMessage = (evt) => {\n                push(new Uint8Array(evt instanceof ArrayBuffer ? evt : evt.data));\n            };\n            sock.addEventListener(\"message\", handleMessage);\n            sock.addEventListener(\"close\", stop);\n            return () => {\n                sock.removeEventListener(\"message\", handleMessage);\n                sock.removeEventListener(\"close\", stop);\n            };\n        }));\n        this.highWaterMark = opts.highWaterMark ?? 1024 * 1024;\n        this.lowWaterMark = opts.lowWaterMark ?? 16 * 1024;\n    }\n    close() {\n        this.sock.close();\n    }\n    get mtu() { return Infinity; }\n    tx = async (iterable) => {\n        try {\n            for await (const pkt of iterable) {\n                if (this.sock.readyState !== this.sock.OPEN) {\n                    throw new Error(`unexpected WebSocket.readyState ${this.sock.readyState}`);\n                }\n                this.sock.send(pkt);\n                if (this.sock.bufferedAmount > this.highWaterMark) {\n                    await this.waitForTxBuffer();\n                }\n            }\n        }\n        finally {\n            this.close();\n        }\n    };\n    waitForTxBuffer() {\n        return new Promise((resolve) => {\n            const timer = setInterval(() => {\n                if (this.sock.bufferedAmount <= this.lowWaterMark || this.sock.readyState !== this.sock.OPEN) {\n                    clearInterval(timer);\n                    resolve();\n                }\n            }, 100);\n        });\n    }\n    reopen() {\n        return WsTransport.connect(this.sock.url, this.opts);\n    }\n}\n(function (WsTransport) {\n    /**\n     * Create a transport and connect to remote endpoint.\n     * @param uri server URI or WebSocket object.\n     * @param opts other options.\n     */\n    function connect(uri, opts = {}) {\n        const { connectTimeout = 10000, signal, } = opts;\n        return new Promise((resolve, reject) => {\n            const sock = typeof uri === \"string\" ? makeWebSocket(uri) : uri;\n            if (sock.readyState === sock.OPEN) {\n                resolve(new WsTransport(sock, opts));\n                return;\n            }\n            let timeout; // eslint-disable-line prefer-const\n            const fail = (err) => {\n                clearTimeout(timeout);\n                sock.close();\n                reject(err);\n            };\n            timeout = setTimeout(() => fail(new Error(\"connectTimeout\")), connectTimeout);\n            const onabort = () => fail(new Error(\"abort\"));\n            signal?.addEventListener(\"abort\", onabort);\n            const onerror = (evt) => {\n                sock.close();\n                reject(new Error(evt.message));\n            };\n            sock.addEventListener(\"error\", onerror);\n            sock.addEventListener(\"open\", () => {\n                clearTimeout(timeout);\n                sock.removeEventListener(\"error\", onerror);\n                signal?.removeEventListener(\"abort\", onabort);\n                resolve(new WsTransport(sock, opts));\n            });\n        });\n    }\n    WsTransport.connect = connect;\n    /** Create a transport and add to forwarder. */\n    WsTransport.createFace = L3Face.makeCreateFace(connect);\n})(WsTransport || (WsTransport = {}));\n","import { Decoder } from \"@ndn/tlv\";\nimport { safeIter } from \"@ndn/util\";\nexport async function* rxFromPacketIterable(iterable) {\n    for await (const pkt of safeIter(iterable)) {\n        const decoder = new Decoder(pkt);\n        let tlv;\n        try {\n            tlv = decoder.read();\n        }\n        catch {\n            continue;\n        }\n        yield tlv;\n    }\n}\n","import { connectToNetwork, connectToRouter } from \"@ndn/autoconfig\";\nimport { Endpoint } from \"@ndn/endpoint\";\nimport { AltUri, Interest, Name } from \"@ndn/packet\";\nimport { WsTransport } from \"@ndn/ws-transport\";\n\nasync function ping(evt) {\n  evt.preventDefault();\n  // Disable the submit button during function execution.\n  const $button = document.querySelector(\"#app_button\");\n  $button.disabled = true;\n\n  try {\n    // Construct the name prefix <user-input>+/ping\n    const prefix = new Name(document.querySelector(\"#app_prefix\").value);\n    const app = document.querySelector(\"#app_param\").value;\n    const $log = document.querySelector(\"#app_log\");\n    $log.textContent = `Check Data \\n${AltUri.ofName(prefix)}\\n`;\n\n    const endpoint = new Endpoint();\n    const encoder = new TextEncoder();\n    // Generate a random number as initial sequence number.\n    let seqNum = Math.trunc(Math.random() * 1e8);\n    for (let i = 0; i < 3; ++i) {\n      ++seqNum;\n      // Construct an Interest with prefix + seqNum.\n      const interest = new Interest();\n      interest.name = prefix;\n      interest.mustBeFresh = true; \n      interest.lifetime = 1000;\n      interest.appParameters = encoder.encode(app);\n      $log.textContent += `\\n${encoder.encode(app)}\\n`;\n      const t0 = Date.now();\n      await interest.updateParamsDigest();\n      try {\n        // Retrieve Data and compute round-trip time.\n        const data = await endpoint.consume(interest);\n        const rtt = Date.now() - t0;\n        const dataContent = data.content;\n        //console.log(dataContent);\n        $log.textContent += `${AltUri.ofName(data.name)} rtt= ${rtt}ms content= ${String.fromCharCode(...dataContent)}\\n`;\n        console.log(`${rtt} ms`);\n      } catch(err) {\n        // Report Data retrieval error.\n        $log.textContent += `\\n${AltUri.ofName(interest.name)} ${err}`;\n      }\n\n      // Delay 500ms before sending the next Interest.\n      await new Promise((r) => setTimeout(r, 500));\n    }\n  } finally {\n    // Re-enable the submit button.\n    $button.disabled = false;\n  }\n}\n\nasync function main() {\n  // Connect to the global NDN network in one line.\n  // This function queries the NDN-FCH service, and connects to the nearest router.\n  //await connectToRouter(\"wss://192.168.56.106:9696/ws/\", {});\n  //await WsTransport.createFace({}, \"wss://testbed-ndn-rg.stei.itb.ac.id/ws/\");\n  await WsTransport.createFace({}, \"ws://192.168.56.111:9696/ws/\");\n  //await WsTransport.createFace({}, \"ws://coba.ndntel-u.my.id/ws/\");\n\n  // Enable the form after connection was successful.\n  document.querySelector(\"#app_button\").disabled = false;\n  document.querySelector(\"#app_form\").addEventListener(\"submit\", ping);\n}\n\nwindow.addEventListener(\"load\", main);\n","export function makeWebSocket(uri) {\n    return new WebSocket(uri, []);\n}\n"],"names":["exports","__esModule","derivedCtor","baseCtors","forEach","baseCtor","Object","getOwnPropertyNames","prototype","name","module","a","b","compare","x","length","y","i","len","Math","min","defineProperty","value","event_iterator_1","EventIterator","subscribe","event","options","evOptions","push","this","addEventListener","removeEventListener","EventQueue","constructor","pullQueue","pushQueue","eventHandlers","isPaused","isStopped","resolution","done","placeholder","shift","resolve","Promise","undefined","highWaterMark","highWater","console","warn","stop","remove","fail","error","reject","rejection","catch","then","removeCallback","Symbol","asyncIterator","next","result","lowWaterMark","lowWater","return","listen","queue","on","fn","freeze","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","call","ownKeys","getOwnPropertySymbols","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","once","emitter","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","warned","w","Error","String","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","n","copy","wrapListener","arg","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","message","context","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","obj","iterator","getIterator","KEEP_ALIVE","getKeepAliveValue","source","sourceNext","async","timer","timeout","setTimeout","race","clearTimeout","shouldKeepAlive","assert","val","msg","equal","l","r","DefaultMap","factory","items","Map","size","clear","peek","has","delete","deleted","callback","scope","entries","values","inspect","for","autoIncrement","DefaultWeakMap","WeakMap","RetryOperation","operation","timeouts","forever","retries","Infinity","unref","maxRetryTime","opts","factor","minTimeout","maxTimeout","randomize","createTimeout","sort","attempt","random","round","max","pow","wrap","methods","method","original","op","retry","mainError","_originalTimeouts","JSON","parse","stringify","_timeouts","_options","_maxRetryTime","_fn","_errors","_attempts","_operationTimeout","_operationTimeoutCb","_timeout","_operationStart","_timer","_cachedTimeouts","reset","currentTime","Date","getTime","splice","self","timeoutOps","cb","try","log","start","errors","attempts","counts","mainErrorCount","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","__importDefault","mod","default","INT2HEX","toString","padStart","toUpperCase","HEX2INT","ch","toLowerCase","toHex","buf","s","fromHex","Uint8Array","TABLE","textEncoder","TextEncoder","textDecoder","TextDecoder","fromUtf8","decode","asDataView","T","ArrayBuffer","buffer","byteOffset","byteLength","asArrayBufferView","DataView","Nni1","encodeTo","encoder","prependRoom","Nni2","setUint16","Nni4","setUint32","Nni8Number","dv","Nni8Big","setBigUint64","decode32","getUint8","getUint16","getUint32","EncodeNniClass","NNI","unsafe","MAX_SAFE_INTEGER","isValidLength","big","getBigUint64","BigInt","isSafeInteger","constrain","typeName","limit0","limit1","trunc","DecodedTlv","offsetT","offsetV","offsetE","subarray","tlv","decoder","Decoder","vd","nni","nniBig","text","before","after","input","eof","offset","read","readVarNum","d","decodeFrom","sizeofVarNum","writeVarNum","room","Encoder","output","initSize","sizeofObject","grow","prependTypeLength","tlvType","tlvLength","sizeofT","sizeofL","prependValue","tlvValue","encode","prependTlv","omitEmpty","hasOmitEmpty","OmitEmpty","sizeBefore","isArray","sizeofRoom","sizeofGrowth","initBufSize","extract","bufferCompare","checkType","t","isInteger","CHAR_ENCODE","fromCodePoint","test","CODEPOINT_PERCENT","codePointAt","CODEPOINT_PERIOD","Component","static","posValue","posEqual","indexOf","iType","parseInt","hasNonPeriods","arg1","assertType","is","convention","match","as","other","from","sign","equals","CompareResult","EQUAL","Name","comps","parseComponent","value_","uri","replace","split","filter","comp","map","valueEncoderBufSize","uri_","hex_","valueHex","at","join","begin","end","getPrefix","append","suffix","replaceAt","commonSize","cmp","comparePrefix","RPREFIX","LPREFIX","isPrefixOf","isNameLike","KeyMap","keyOf","KeyMultiMap","size_","dimension","Set","add","c","associations","KeyMultiSet","multiplicities","nameOrHex","NameMap","super","NameMultiMap","NameMultiSet","printTT","isCritical","tt","EvDecoder","topTT","rules","requiredTT","nextOrder","unknownHandler","beforeObservers","afterObservers","order","required","repeat","evd","setIsCritical","setUnknown","topTlv","includes","decodeV","decodeValue","currentOrder","foundTT","missingTT","rule","handleUnrecognized","reason","globalThis","crypto","sha256","digest","subtle","EVD","FwHint","delegations","FIELDS","definePublicFields","typ","fieldDefs","field","clearing","v","f","DigestComp","altUriPrefix","altUriRegex","RegExp","toAltUri","fromAltUri","exec","ImplicitDigest","strip","PARAMS_PLACEHOLDER_TAG","ParamsDigest","PLACEHOLDER","assign","isPlaceholder","findIn","matchPlaceholder","findIndex","KeyLocator","isCtorArg","mustGetName","kl","RECORDS","Extensible","Extension","TAG","cloneRecord","dst","src","EXTENSIONS","table","registerExtension","ext","unregisterExtension","decodeUnknown","record","fields","keyLocator","nonce","time","seqNum","SigInfo","klArgs","ctorAssign","encodeAs","LLSign","LLVerify","Signer","Verifier","generateNonce","getRandomValues","Nonce","si","Time","now","SeqNum","OP","putSigInfo","pkt","sigType","sigInfo","checkSigType","expectedSigType","throwOnBadSig","ok","Fields","fwHint","appParameters","Interest","canBePrefix","mustBeFresh","nonce_","lifetime","lifetime_","DefaultLifetime","hopLimit","hopLimit_","sigValue","paramsPortion","signedPortion","signedPart0","signedPart1","interest","encodeParamsPortion","appendParamsDigestPlaceholder","pdIndex","requireAppParameters","pdComp","updateParamsDigest","verify","validateParamsDigest","CanBePrefix","MustBeFresh","Lifetime","HopLimit","makeModifyFunc","patch","isFinalBlock","content","Data","FinalBlock","contentType","contentType_","freshnessPeriod","freshnessPeriod_","finalBlockId","topTlvDigest","data","encodeSignedPortion","getImplicitDigest","getFullName","computeImplicitDigest","fullName","computeFullName","clearingFields","ContentType","FreshnessPeriod","NackHeader","reason_","Nack","header","safeIter","iterable","onError","flatMapOnce","item","FixedFIFO","hwm","mask","top","btm","last","isEmpty","FIFO","splitLimit","head","tail","calculateSize","prev","pushable","getNext","onNext","ended","onEnd","bufferNext","objectMode","bufferError","throw","readableLength","_pushable","consume","_val","_consume","_filter","filterFunc","curriedIterable","flatten","maybeItr","_map","func","flatMap","_flatTransform","concurrency","resultQueue","readQueue","reading","inflightCount","lastError","fulfillReadQueue","fillQueue","itrValue","asyncVal","mapAndQueue","asyncIterableIterator","deferred","promise","resolveFunc","rejectFunc","defer","flatTransform","curriedFunc","pipeline","firstFn","fns","previousFn","_reduce","nextItem","reduce","curriedStart","_asyncTap","tap","computeAnnouncement","announcement","FaceImpl","fw","rxtx","attributes","routes","announcements","running","txQueue","local","advertiseFrom","routeCapture","faces","txLoop","rxtxD","duplex","rxtxS","tx","rx","duplexFromRxTx","rxLoop","handleLowerUp","handleLowerDown","close","fib","readvertise","removeAnnouncement","describe","hasRoute","nameInput","addRoute","insert","ann","addAnnouncement","removeRoute","send","l3","cancel","processData","processNack","FibEntry","nexthops","Fib","face","nameHex","capture","entry","lookup","prefixes","lpm","prefixHex","nh","FwPacket","toFixed","e","startedAt","seconds","milliseconds","ms","microseconds","us","nanoseconds","ns","process","hrtime","window","performance","token","isEncodable","RejectInterest","CancelInterest","getNow","PitEntry","pit","dnRecords","nRx","expire","lastExpire","expireTimer","receiveInterest","dnR","updateExpire","cancelInterest","forwardInterest","up","eraseEntry","dn","insertEntry","Pit","dataNoTokenMatch","byName","byToken","lastToken","generateToken","canInsert","findPotentialMatches","canSatisfy","returnData","dnToken","keySuffixes","prefix","keySuffix","Readvertise","destinations","dest","advertise","withdraw","disable","ReadvertiseDestination","retryOptions","closed","enable","status","Status","WITHDRAWING","ADVERTISING","makeState","restart","doAdvertise","ADVERTISED","doWithdraw","WITHDRAWN","Forwarder","defaultInstance","DefaultOptions","ForwarderImpl","getDefault","replaceDefault","deleteDefault","nodeNames","addFace","pickInterestForwardingName","fhName","every","nodeName","processInterest","pi","fwName","satisfy","nack","makeRetxGenerator","policy","limit","interestLifetime","interval","backoff","jitter","distance","randomJitter","nextInterval","AbortSignal","applyMixins","Endpoint","interestInput","signal","modifyInterest","retx","verifier","nRetx","retxGen","cancelRetx","sendInterest","onAbort","defineProperties","produce","prefixInput","dataSigner","dataBuffer","autoBuffer","producer","processInterestUnbuffered","signUnsignedData","found","find","deleteDefaultForwarder","AltUri","conventions","ofComponent","conv","ofName","parseName","Transport","mtu","reopen","ReopenNotSupportedError","fragSeqNum","fragIndex","fragCount","pitToken","payload","LpPacket","encodeL3Headers","copyL3HeadersFrom","SeqNumGen","current","asUintN","Fragmenter","seqNumGen","fragment","full","fragmentRoom","sizeofL3Headers","sizeofPayload","sizeofFirstFragment","fragments","first","PartialPacket","seqNumBase","accepted","payloadLength","accept","acceptOne","reassemble","parts","part","totalLength","concatBuffers","Reassembler","capacity","partials","partial","getPartial","putPartial","itKeepAlive","IDLE","LpService","transport","keepAlive","reassemblerCapacity","isFinite","ceil","reassembler","fragmenter","dtlv","decodeL3","lpp","l3pkt","RxError","TxError","packet","inner","AbortError","code","abortableSource","nextAbortHandler","abortHandler","aborted","abortMessage","abortCode","abort","isKnownAborter","p","onReturnError","returnOnAbort","abortable","L3Face","lp","wireTokenPrefix","state_","newState","State","UP","DOWN","CLOSED","rxSources","reopenRetry","lpOptions","makeRx","rxTransform","transportRx","wireToken","internalToken","txTransform","fwTx","txSourceIterator","txSourceIterable","reopenTransport","AbortController","handleStateChange","txSource","processAddRoutes","fwFace","addRoutes","routeName","makeCreateFace","createTransport","created","makeFace","l3face","WsTransport","sock","url","binaryType","rxFromPacketIterable","handleMessage","evt","readyState","OPEN","bufferedAmount","waitForTxBuffer","setInterval","clearInterval","connect","ping","preventDefault","$button","document","querySelector","disabled","app","$log","textContent","endpoint","t0","rtt","dataContent","fromCharCode","connectTimeout","WebSocket","makeWebSocket","onabort","onerror","createFace"],"sourceRoot":""}