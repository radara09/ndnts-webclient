import { L3Face, rxFromPacketIterable, Transport } from "@ndn/l3face";
/** HTTP/3 transport. */
export class H3Transport extends Transport {
    uri;
    tr;
    /** Whether current browser supports WebTransport. */
    static supported = !!globalThis.WebTransport;
    rx;
    constructor(uri, tr) {
        super({
            describe: `H3(${uri})`,
        });
        this.uri = uri;
        this.tr = tr;
        this.rx = rxFromPacketIterable((async function* () {
            const reader = tr.datagrams.readable.getReader();
            while (true) {
                const result = await reader.read();
                if (result.done) {
                    break;
                }
                yield result.value;
            }
        })());
    }
    get mtu() {
        return this.tr.datagrams.maxDatagramSize;
    }
    tx = async (iterable) => {
        const writer = this.tr.datagrams.writable.getWriter();
        try {
            for await (const pkt of iterable) {
                await writer.write(pkt);
            }
            await writer.close();
        }
        finally {
            this.tr.close();
        }
    };
    reopen() {
        return H3Transport.connect(this.uri);
    }
}
(function (H3Transport) {
    /**
     * Create a transport and connect to remote endpoint.
     * @param uri server URI.
     */
    async function connect(uri) {
        const tr = new globalThis.WebTransport(uri);
        void tr.closed.catch(() => undefined);
        await tr.ready;
        return new H3Transport(uri, tr);
    }
    H3Transport.connect = connect;
    /** Create a transport and add to forwarder. */
    H3Transport.createFace = L3Face.makeCreateFace(H3Transport.connect);
})(H3Transport || (H3Transport = {}));
