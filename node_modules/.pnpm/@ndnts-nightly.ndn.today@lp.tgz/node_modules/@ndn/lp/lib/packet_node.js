import { NackHeader } from "@ndn/packet";
import { Encoder, EvDecoder, NNI } from "@ndn/tlv";
import { asDataView } from "@ndn/util";
import { TT } from "./an_node.js";
function isCritical(tt) {
    return !(tt >= 800 && tt <= 959 && tt % 4 === 0);
}
const EVD = new EvDecoder("LpPacket", TT.LpPacket)
    .setIsCritical(isCritical)
    .add(TT.LpSeqNum, (t, { value }) => t.fragSeqNum = asDataView(value).getBigUint64(0))
    .add(TT.FragIndex, (t, { nni }) => t.fragIndex = nni)
    .add(TT.FragCount, (t, { nni }) => t.fragCount = nni)
    .add(TT.PitToken, (t, { value }) => t.pitToken = value)
    .add(TT.Nack, (t, { decoder }) => t.nack = decoder.decode(NackHeader))
    .add(TT.LpPayload, (t, { value }) => t.payload = value);
/** NDNLPv2 packet. */
export class LpPacket {
    static decodeFrom(decoder) {
        return EVD.decode(new LpPacket(), decoder);
    }
    fragSeqNum;
    fragIndex = 0;
    fragCount = 1;
    pitToken;
    nack;
    payload;
    encodeTo(encoder) {
        encoder.prependTlv(TT.LpPacket, this.fragSeqNum !== undefined && [TT.LpSeqNum, NNI(this.fragSeqNum, { len: 8 })], this.fragIndex > 0 && [TT.FragIndex, NNI(this.fragIndex)], this.fragCount > 1 && [TT.FragCount, NNI(this.fragCount)], ...this.encodeL3Headers(), [TT.LpPayload, Encoder.OmitEmpty, this.payload]);
    }
    encodeL3Headers() {
        return [
            [TT.PitToken, Encoder.OmitEmpty, this.pitToken],
            this.nack,
        ];
    }
    copyL3HeadersFrom(src) {
        this.pitToken = src.pitToken;
        this.nack = src.nack;
    }
}
