import { CancelInterest, FwPacket } from "@ndn/fw";
import { Data, Interest } from "@ndn/packet";
import { pushable } from "it-pushable";
import { makeRetxGenerator } from "./retx_node.js";
/** Consumer functionality of Endpoint. */
export class EndpointConsumer {
    /** Consume a single piece of Data. */
    consume(interestInput, opts = {}) {
        const interest = interestInput instanceof Interest ? interestInput : new Interest(interestInput);
        const { describe = `consume(${interest.name})`, signal, modifyInterest, retx, verifier, } = { ...this.opts, ...opts };
        Interest.makeModifyFunc(modifyInterest)(interest);
        let nRetx = -1;
        const retxGen = makeRetxGenerator(retx)(interest.lifetime)[Symbol.iterator]();
        const promise = new Promise((resolve, reject) => {
            const rx = pushable({ objectMode: true });
            let timer;
            const cancelRetx = () => {
                clearTimeout(timer);
                timer = undefined;
            };
            const sendInterest = () => {
                cancelRetx();
                const { value, done } = retxGen.next();
                if (!done) {
                    timer = setTimeout(sendInterest, value);
                }
                rx.push(FwPacket.create(interest));
                ++nRetx;
            };
            const onAbort = () => {
                cancelRetx();
                rx.push(new CancelInterest(interest));
            };
            signal?.addEventListener("abort", onAbort);
            this.fw.addFace({
                rx,
                async tx(iterable) {
                    for await (const pkt of iterable) {
                        if (pkt.l3 instanceof Data) {
                            try {
                                await verifier?.verify(pkt.l3);
                            }
                            catch (err) {
                                reject(new Error(`Data verify failed: ${err} @${describe}`));
                                break;
                            }
                            resolve(pkt.l3);
                            break;
                        }
                        if (pkt.reject && !timer) {
                            reject(new Error(`Interest rejected: ${pkt.reject} @${describe}`));
                            break;
                        }
                    }
                    cancelRetx();
                    signal?.removeEventListener("abort", onAbort);
                    rx.end();
                },
            }, {
                describe,
                local: true,
            });
            sendInterest();
        });
        return Object.defineProperties(promise, {
            interest: { value: interest },
            nRetx: { get() { return nRetx; } },
        });
    }
}
