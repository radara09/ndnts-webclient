import { FwPacket } from "@ndn/fw";
import { Data, Interest, Name, SigType } from "@ndn/packet";
import { flatTransform } from "streaming-iterables";
/** Producer functionality of Endpoint. */
export class EndpointProducer {
    /**
     * Start a producer.
     * @param prefixInput prefix registration; if undefined, prefixes may be added later.
     * @param handler function to handle incoming Interest.
     */
    produce(prefixInput, handler, opts = {}) {
        const prefix = prefixInput === undefined ? undefined : new Name(prefixInput);
        const { describe = `produce(${prefix})`, signal, routeCapture = true, announcement, concurrency = 1, dataSigner, dataBuffer, autoBuffer = true, } = { ...this.opts, ...opts };
        let producer; // eslint-disable-line prefer-const
        const processInterestUnbuffered = async (interest) => {
            const data = await handler(interest, producer);
            if (!(data instanceof Data)) {
                return undefined;
            }
            await signUnsignedData(data, dataSigner);
            if (!await data.canSatisfy(interest)) {
                return undefined;
            }
            return data;
        };
        let processInterest = processInterestUnbuffered;
        if (dataBuffer) {
            processInterest = async (interest) => {
                let found = await dataBuffer.find(interest);
                if (!found) {
                    const output = await processInterestUnbuffered(interest);
                    if (output) {
                        if (autoBuffer) {
                            await dataBuffer.insert(output);
                        }
                        return output;
                    }
                    found = await dataBuffer.find(interest);
                }
                return found;
            };
        }
        const face = this.fw.addFace({
            duplex: flatTransform(concurrency, async function* ({ l3: interest, token }) {
                if (!(interest instanceof Interest)) {
                    return;
                }
                const data = await processInterest(interest).catch(() => undefined);
                if (!data) {
                    return;
                }
                yield FwPacket.create(data, token);
            }),
        }, {
            describe,
            local: true,
            routeCapture,
        });
        if (prefix) {
            face.addRoute(prefix, announcement);
        }
        const onAbort = () => {
            face.close();
            signal?.removeEventListener("abort", onAbort);
        };
        signal?.addEventListener("abort", onAbort);
        producer = {
            prefix,
            face,
            dataBuffer,
            processInterest,
            close: onAbort,
        };
        return producer;
    }
}
export async function signUnsignedData(data, dataSigner) {
    if (dataSigner && data.sigInfo.type === SigType.Null) {
        await dataSigner.sign(data);
    }
}
