import { __importDefault, __importStar } from "tslib";
import { L3Face, rxFromPacketIterable, Transport } from "@ndn/l3face";
import _cjsDefaultImport0 from "event-iterator"; const EventIterator = __importDefault(_cjsDefaultImport0).default;
import { joinHostPort } from "./hostport_node.js";
import * as udp from "./udp-helper_node.js";
/** UDP socket transport. */
export class UdpTransport extends Transport {
    rx;
    isMulticast;
    laddr;
    raddr;
    rxSock;
    txSock;
    constructor(txSock, rxSock) {
        const [scheme, { address, port }] = rxSock ? ["UDPm", txSock.address()] : ["UDP", txSock.remoteAddress()];
        super({
            describe: `${scheme}(${joinHostPort(address, port)})`,
            multicast: !!rxSock,
        });
        if (rxSock) {
            this.isMulticast = true;
            this.rxSock = rxSock;
            this.txSock = txSock;
            txSock.once("error", () => this.rxSock.close());
            this.laddr = this.txSock.address();
            this.raddr = this.rxSock.address();
        }
        else {
            this.isMulticast = false;
            this.rxSock = txSock;
            this.txSock = txSock;
            this.laddr = this.txSock.address();
            this.raddr = this.txSock.remoteAddress();
        }
        this.rx = rxFromPacketIterable(new EventIterator(({ push, stop, fail }) => {
            const handleMessage = (msg) => push(msg);
            this.rxSock.on("message", handleMessage);
            this.rxSock.on("close", stop);
            this.rxSock.on("error", fail);
            return () => {
                this.rxSock.off("message", handleMessage);
                this.rxSock.off("close", stop);
                this.rxSock.off("error", fail);
            };
        }));
    }
    get mtu() { return udp.DEFAULT_MTU; }
    close() {
        try {
            this.rxSock.close();
            if (this.txSock !== this.rxSock) {
                this.txSock.close();
            }
        }
        catch { }
    }
    tx = async (iterable) => {
        try {
            for await (const pkt of iterable) {
                this.txSock.send(pkt);
            }
        }
        finally {
            this.close();
        }
    };
}
(function (UdpTransport) {
    function connect(arg1, port) {
        return connectImpl(arg1, port);
    }
    UdpTransport.connect = connect;
    async function connectImpl(arg1, port) {
        const opts = typeof arg1 === "string" ? { host: arg1, port } : arg1;
        const sock = await udp.openUnicast(opts);
        return new UdpTransport(sock);
    }
    /** Create a unicast transport and add to forwarder. */
    UdpTransport.createFace = L3Face.makeCreateFace(connectImpl);
    /** Create a multicast transport. */
    async function multicast(opts) {
        const tx = await udp.openMulticastTx(opts);
        let rx;
        try {
            rx = await udp.openMulticastRx(opts);
        }
        catch (err) {
            tx.close();
            throw err;
        }
        return new UdpTransport(tx, rx);
    }
    UdpTransport.multicast = multicast;
    /** Create a multicast transport and add to forwarder. */
    UdpTransport.createMulticastFace = L3Face.makeCreateFace(multicast);
    /** Create multicast transports on every interface. */
    async function multicasts(opts = {}) {
        const intfs = udp.listMulticastIntfs();
        return (await Promise.allSettled(intfs.map((intf) => multicast({ ...opts, intf }))))
            .filter((res) => res.status === "fulfilled")
            .map(({ value }) => value);
    }
    UdpTransport.multicasts = multicasts;
    /** Create multicast transports on every interface. */
    UdpTransport.createMulticastFaces = L3Face.makeCreateFace(multicasts);
})(UdpTransport || (UdpTransport = {}));
