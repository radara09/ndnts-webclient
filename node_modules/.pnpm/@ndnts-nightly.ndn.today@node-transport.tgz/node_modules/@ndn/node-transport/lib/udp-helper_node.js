import * as dgram from "node:dgram";
import { once } from "node:events";
import * as os from "node:os";
export const DEFAULT_MTU = 65000;
const DEFAULT_UNICAST_PORT = 6363;
const DEFAULT_MULTICAST_GROUP = "224.0.23.170";
const DEFAULT_MULTICAST_PORT = 56363;
export function intfHasAddressFamily(want, { family }) {
    // https://github.com/nodejs/node/issues/42787
    // Node.js 16.x: NetworkInterfaceInfo.family is either "IPv4" or "IPv6"
    // Node.js 18.x: NetworkInterfaceInfo.family is either 4 or 6
    return family === want || family === `IPv${want}`;
}
export async function openSocket({ family, recvBufferSize, sendBufferSize, bind = {}, }) {
    family ??= bind.address?.includes(":") ? 6 : 4;
    const sock = dgram.createSocket({
        type: `udp${family}`,
        reuseAddr: true,
        recvBufferSize,
        sendBufferSize,
    });
    try {
        sock.bind(bind);
        await once(sock, "listening");
    }
    catch (err) {
        sock.close();
        throw err;
    }
    return sock;
}
export async function connect(sock, { host, port = DEFAULT_UNICAST_PORT, }) {
    try {
        sock.connect(port, host);
        await once(sock, "connect");
    }
    catch (err) {
        sock.close();
        throw err;
    }
    return sock;
}
export async function openUnicast(opts) {
    if (!opts.family && opts.host.includes(":")) {
        opts.family = 6;
    }
    const sock = await openSocket(opts);
    return connect(sock, opts);
}
/**
 * List network interfaces capable of IPv4 multicast.
 * @returns IPv4 address of each network interface.
 */
export function listMulticastIntfs() {
    return Object.values(os.networkInterfaces())
        .flatMap((addrs = []) => addrs.filter((a) => intfHasAddressFamily(4, a) && !a.internal)
        .map(({ address }) => address).slice(0, 1));
}
export async function openMulticastRx(opts) {
    const { intf, group = DEFAULT_MULTICAST_GROUP, port = DEFAULT_MULTICAST_PORT, multicastLoopback = false, } = opts;
    const sock = await openSocket({
        ...opts,
        bind: { port },
    });
    try {
        sock.setBroadcast(true);
        sock.setMulticastLoopback(multicastLoopback);
        sock.addMembership(group, intf);
    }
    catch (err) {
        sock.close();
        throw err;
    }
    return sock;
}
export async function openMulticastTx(opts) {
    const { intf, group = DEFAULT_MULTICAST_GROUP, port = DEFAULT_MULTICAST_PORT, multicastTtl = 1, } = opts;
    const sock = await openSocket({
        ...opts,
        bind: { address: intf, port },
    });
    try {
        sock.setMulticastTTL(multicastTtl);
        sock.setMulticastInterface(intf);
        sock.connect(port, group);
        await once(sock, "connect");
    }
    catch (err) {
        sock.close();
        throw err;
    }
    return sock;
}
