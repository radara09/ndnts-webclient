import { Encoder, EvDecoder, Extensible, ExtensionRegistry, NNI } from "@ndn/tlv";
import { assert, crypto } from "@ndn/util";
import { SigType, TT } from "./an_node.js";
import { KeyLocator } from "./key-locator_node.js";
const EXTENSIONS = new ExtensionRegistry();
const EVD = new EvDecoder("SigInfo", [TT.ISigInfo, TT.DSigInfo])
    .add(TT.SigType, (t, { nni }) => t.type = nni, { required: true })
    .add(TT.KeyLocator, (t, { decoder }) => t.keyLocator = decoder.decode(KeyLocator))
    .add(TT.SigNonce, (t, { value }) => t.nonce = value)
    .add(TT.SigTime, (t, { nni }) => t.time = nni)
    .add(TT.SigSeqNum, (t, { nniBig }) => t.seqNum = nniBig)
    .setUnknown(EXTENSIONS.decodeUnknown);
/** SignatureInfo on Interest or Data. */
export class SigInfo {
    static decodeFrom(decoder) {
        return EVD.decode(new SigInfo(), decoder);
    }
    type = SigType.Null;
    keyLocator;
    nonce;
    time;
    seqNum;
    [Extensible.TAG] = EXTENSIONS;
    /**
     * Construct from flexible arguments.
     *
     * Arguments can include, in any order:
     * - SigInfo to copy from
     * - number as SigType
     * - KeyLocator, or Name/URI/KeyDigest to construct KeyLocator
     * - SigInfo.Nonce(v)
     * - SigInfo.Time(v)
     * - SigInfo.SeqNum(v)
     */
    constructor(...args) {
        const klArgs = [];
        for (const arg of args) {
            if (typeof arg === "number") {
                this.type = arg;
            }
            else if (KeyLocator.isCtorArg(arg)) {
                klArgs.push(arg);
            }
            else if (arg instanceof SigInfo) {
                Object.assign(this, arg);
                Extensible.cloneRecord(this, arg);
            }
            else if (arg[ctorAssign]) {
                arg[ctorAssign](this);
            }
            else {
                throw new Error("unknown SigInfo constructor argument");
            }
        }
        if (klArgs.length > 0) {
            this.keyLocator = new KeyLocator(...klArgs);
        }
    }
    /**
     * Create an Encodable.
     * @param tt either TT.ISigInfo or TT.DSigInfo.
     */
    encodeAs(tt) {
        return {
            encodeTo: (encoder) => this.encodeTo(encoder, tt),
        };
    }
    encodeTo(encoder, tt) {
        encoder.prependTlv(tt, [TT.SigType, NNI(this.type)], this.keyLocator, [TT.SigNonce, Encoder.OmitEmpty, this.nonce], this.time !== undefined && [TT.SigTime, NNI(this.time)], this.seqNum !== undefined && [TT.SigSeqNum, NNI(this.seqNum)], ...EXTENSIONS.encode(this));
    }
}
const ctorAssign = Symbol("SigInfo.ctorAssign");
(function (SigInfo) {
    function Nonce(v) {
        return {
            [ctorAssign](si) {
                si.nonce = v instanceof Uint8Array ? v : generateNonce(v);
            },
        };
    }
    SigInfo.Nonce = Nonce;
    /** Generate a random nonce. */
    function generateNonce(size = 8) {
        assert(size >= 1);
        return crypto.getRandomValues(new Uint8Array(size));
    }
    SigInfo.generateNonce = generateNonce;
    function Time(v = Date.now()) {
        return {
            [ctorAssign](si) { si.time = v; },
        };
    }
    SigInfo.Time = Time;
    function SeqNum(v) {
        return {
            [ctorAssign](si) { si.seqNum = v; },
        };
    }
    SigInfo.SeqNum = SeqNum;
    SigInfo.registerExtension = EXTENSIONS.registerExtension;
    SigInfo.unregisterExtension = EXTENSIONS.unregisterExtension;
})(SigInfo || (SigInfo = {}));
