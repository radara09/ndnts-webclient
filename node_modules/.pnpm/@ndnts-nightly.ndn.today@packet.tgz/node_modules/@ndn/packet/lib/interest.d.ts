import { type Decoder, Encoder } from "@ndn/tlv";
import { FwHint } from "./fwhint.js";
import { FIELDS } from "./impl-public-fields.js";
import { type NameLike, Name } from "./name/mod.js";
import { type Signer, type Verifier, LLSign, LLVerify } from "./security/signing.js";
import { SigInfo } from "./sig-info.js";
declare class Fields {
    constructor(...args: Array<Interest | Interest.CtorArg>);
    name: Name;
    canBePrefix: boolean;
    mustBeFresh: boolean;
    fwHint?: FwHint;
    get nonce(): number | undefined;
    set nonce(v: number | undefined);
    private nonce_;
    get lifetime(): number;
    set lifetime(v: number);
    private lifetime_;
    get hopLimit(): number;
    set hopLimit(v: number);
    private hopLimit_;
    appParameters?: Uint8Array;
    sigInfo?: SigInfo;
    sigValue: Uint8Array;
    paramsPortion?: Uint8Array;
    signedPortion?: Uint8Array;
}
interface PublicFields extends Omit<Fields, "paramsPortion" | "signedPortion"> {
}
/** Interest packet. */
export declare class Interest implements LLSign.Signable, LLVerify.Verifiable, Signer.Signable, Verifier.Verifiable {
    /**
     * Construct from flexible arguments.
     *
     * Arguments can include, in any order:
     * - Interest to copy from
     * - Name or name URI
     * - Interest.CanBePrefix
     * - Interest.MustBeFresh
     * - FwHint
     * - Interest.Nonce(v)
     * - Interest.Lifetime(v)
     * - Interest.HopLimit(v)
     * - Uint8Array as AppParameters
     */
    constructor(...args: Array<Interest | Interest.CtorArg>);
    readonly [FIELDS]: Fields;
    static decodeFrom(decoder: Decoder): Interest;
    encodeTo(encoder: Encoder): void;
    private encodeParamsPortion;
    private appendParamsDigestPlaceholder;
    updateParamsDigest(): Promise<void>;
    validateParamsDigest(requireAppParameters?: boolean): Promise<void>;
    [LLSign.OP](sign: LLSign): Promise<void>;
    [LLVerify.OP](verify: LLVerify): Promise<void>;
}
export interface Interest extends PublicFields {
}
declare const ctorAssign: unique symbol;
interface CtorTag {
    [ctorAssign]: (f: Fields) => void;
}
export declare namespace Interest {
    /** Generate a random nonce. */
    function generateNonce(): number;
    /** Default InterestLifetime. */
    const DefaultLifetime = 4000;
    /** Constructor argument to set CanBePrefix flag. */
    const CanBePrefix: CtorTag;
    /** Constructor argument to set MustBeFresh flag. */
    const MustBeFresh: CtorTag;
    /** Constructor argument to set Nonce field. */
    function Nonce(v?: number): CtorTag;
    /** Constructor argument to set InterestLifetime field. */
    function Lifetime(v: number): CtorTag;
    /** Constructor argument to set HopLimit field. */
    function HopLimit(v: number): CtorTag;
    /** Constructor argument. */
    type CtorArg = NameLike | FwHint | CtorTag | Uint8Array;
    /** A function to modify an existing Interest. */
    type ModifyFunc = (interest: Interest) => void;
    /** Common fields to assign onto an existing Interest. */
    type ModifyFields = Partial<Pick<Fields, "canBePrefix" | "mustBeFresh" | "fwHint" | "lifetime" | "hopLimit">>;
    /** A structure to modify an existing Interest. */
    type Modify = ModifyFunc | ModifyFields;
    /** Turn ModifyFields to ModifyFunc; return ModifyFunc as-is. */
    function makeModifyFunc(input?: Modify): ModifyFunc;
}
export {};
