import { EvDecoder, NNI } from "@ndn/tlv";
import { NackReason, TT } from "./an_browser.js";
const EVD = new EvDecoder("NackHeader", TT.Nack)
    .add(TT.NackReason, (t, { nni }) => t.reason = nni);
/** Nack header. */
export class NackHeader {
    get reason() { return this.reason_; }
    set reason(v) { this.reason_ = NNI.constrain(v, "Reason"); }
    reason_ = 0;
    static decodeFrom(decoder) {
        return EVD.decode(new NackHeader(), decoder);
    }
    constructor(reason = 0) {
        this.reason = reason;
    }
    encodeTo(encoder) {
        encoder.prependTlv(TT.Nack, this.reason_ > 0 && [TT.NackReason, NNI(this.reason_)]);
    }
}
/** Nack packet. */
export class Nack {
    interest;
    get reason() { return this.header.reason; }
    set reason(v) { this.header.reason = v; }
    header;
    constructor(interest, header = NackReason.NoRoute) {
        this.interest = interest;
        if (typeof header === "number") {
            this.header = new NackHeader(header);
        }
        else {
            this.header = header;
        }
    }
}
