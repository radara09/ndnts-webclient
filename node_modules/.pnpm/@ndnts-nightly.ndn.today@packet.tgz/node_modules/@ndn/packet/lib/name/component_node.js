import { __importDefault, __importStar } from "tslib";
import { Decoder, Encoder } from "@ndn/tlv";
import { fromHex, fromUtf8, toHex, toUtf8 } from "@ndn/util";
import _cjsDefaultImport0 from "buffer-compare"; const bufferCompare = __importDefault(_cjsDefaultImport0).default;
import { TT } from "../an_node.js";
function checkType(t) {
    return Number.isInteger(t) && t >= 0x01 && t <= 0xFFFF;
}
function assertType(t) {
    if (!checkType(t)) {
        throw new Error(`Component TLV-TYPE ${t} out of range`);
    }
}
const CHAR_ENCODE = {};
for (let b = 0x00; b <= 0xFF; ++b) {
    const s = String.fromCodePoint(b);
    CHAR_ENCODE[b] = /[\w.~-]/i.test(s) ? s : `%${toHex.TABLE[b]}`;
}
const CODEPOINT_PERCENT = "%".codePointAt(0);
const CODEPOINT_PERIOD = ".".codePointAt(0);
/**
 * Name component.
 * This type is immutable.
 */
export class Component {
    static decodeFrom(decoder) {
        const { tlv } = decoder.read();
        return new Component(tlv);
    }
    /** Parse from URI representation, or return existing Component. */
    static from(input) {
        if (input instanceof Component) {
            return input;
        }
        let type = TT.GenericNameComponent;
        let posValue = 0;
        const posEqual = input.indexOf("=");
        if (posEqual >= 1) {
            const iType = Number.parseInt(input, 10);
            if (checkType(iType)) {
                type = iType;
                posValue = posEqual + 1;
            }
        }
        const value = new Uint8Array(input.length - posValue);
        let length = 0;
        let hasNonPeriods = false;
        for (let i = posValue; i < input.length;) {
            let b = input.codePointAt(i);
            hasNonPeriods ||= b !== CODEPOINT_PERIOD;
            if (b === CODEPOINT_PERCENT) {
                b = (fromHex.TABLE[input[i + 1]] << 4) | fromHex.TABLE[input[i + 2]];
                i += 3;
            }
            else {
                ++i;
            }
            value[length++] = b;
        }
        if (!hasNonPeriods && length >= 3) {
            length -= 3;
        }
        return new Component(type, value.subarray(0, length));
    }
    /** Whole TLV. */
    tlv;
    /** TLV-TYPE. */
    type;
    /** TLV-VALUE. */
    value;
    /** TLV-LENGTH. */
    get length() {
        return this.value.length;
    }
    /** TLV-VALUE interpreted as UTF-8 string. */
    get text() {
        return fromUtf8(this.value);
    }
    constructor(arg1 = TT.GenericNameComponent, value = new Uint8Array()) {
        if (arg1 instanceof Uint8Array) {
            this.tlv = arg1;
            const decoder = new Decoder(arg1);
            ({ type: this.type, value: this.value } = decoder.read());
        }
        else {
            this.type = arg1;
            if (typeof value === "string") {
                value = toUtf8(value);
            }
            this.tlv = Encoder.encode([this.type, value], 10 + value.length);
            this.value = this.tlv.subarray(this.tlv.length - value.length);
        }
        assertType(this.type);
    }
    /** Get URI string. */
    toString() {
        let s = `${this.type}=`;
        let hasNonPeriods = false;
        for (const b of this.value) {
            hasNonPeriods ||= b !== CODEPOINT_PERIOD;
            s += CHAR_ENCODE[b];
        }
        if (!hasNonPeriods) {
            s += "...";
        }
        return s;
    }
    encodeTo(encoder) {
        encoder.encode(this.tlv);
    }
    /** Determine if component follows a naming convention. */
    is(convention) {
        return convention.match(this);
    }
    /** Convert with naming convention. */
    as(convention) {
        if (!convention.match(this)) {
            throw new Error("component does not follow convention");
        }
        return convention.parse(this);
    }
    /** Compare this component with other. */
    compare(other) {
        other = Component.from(other);
        return 2 * Math.sign(this.type - other.type || this.length - other.length ||
            bufferCompare(this.value, other.value));
    }
    /** Determine if this component equals other. */
    equals(other) {
        return this.compare(other) === Component.CompareResult.EQUAL;
    }
}
(function (Component) {
    /** Component compare result. */
    let CompareResult;
    (function (CompareResult) {
        /** lhs is less than rhs */
        CompareResult[CompareResult["LT"] = -2] = "LT";
        /** lhs and rhs are equal */
        CompareResult[CompareResult["EQUAL"] = 0] = "EQUAL";
        /** lhs is greater than rhs */
        CompareResult[CompareResult["GT"] = 2] = "GT";
    })(CompareResult = Component.CompareResult || (Component.CompareResult = {}));
})(Component || (Component = {}));
