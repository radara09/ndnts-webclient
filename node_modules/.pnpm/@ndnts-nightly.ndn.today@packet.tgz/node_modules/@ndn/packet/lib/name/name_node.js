import { Decoder, Encoder } from "@ndn/tlv";
import { toHex } from "@ndn/util";
import { TT } from "../an_node.js";
import { Component } from "./component_node.js";
/**
 * Name.
 * This type is immutable.
 */
export class Name {
    static decodeFrom(decoder) {
        const { value } = decoder.read();
        return new Name(value);
    }
    /** List of name components. */
    comps;
    constructor(arg1, parseComponent = Component.from) {
        switch (true) {
            case arg1 instanceof Name: {
                const other = arg1;
                this.comps = other.comps;
                this.value_ = other.value_;
                break;
            }
            case typeof arg1 === "string": {
                const uri = arg1;
                this.comps = uri.replace(/^(?:ndn:)?\/*/, "").split("/")
                    .filter((comp) => comp !== "").map(parseComponent);
                this.valueEncoderBufSize = uri.length + 4 * this.comps.length;
                break;
            }
            case Array.isArray(arg1): {
                this.comps = Array.from(arg1, Component.from);
                break;
            }
            case arg1 instanceof Uint8Array: {
                this.value_ = arg1;
                const comps = [];
                const decoder = new Decoder(this.value_);
                while (!decoder.eof) {
                    comps.push(decoder.decode(Component));
                }
                this.comps = comps;
                break;
            }
            default: { // undefined
                this.comps = [];
                this.valueEncoderBufSize = 0;
                break;
            }
        }
    }
    valueEncoderBufSize;
    value_;
    uri_;
    hex_;
    /** Number of name components. */
    get length() {
        return this.comps.length;
    }
    /** Name TLV-VALUE. */
    get value() {
        if (!this.value_) {
            this.value_ = Encoder.encode(this.comps, this.valueEncoderBufSize ?? 256);
        }
        return this.value_;
    }
    /** Name TLV-VALUE hexadecimal representation, good for map keys. */
    get valueHex() {
        this.hex_ ??= toHex(this.value);
        return this.hex_;
    }
    /** Retrieve i-th component. */
    get(i) {
        i = i < 0 ? i + this.length : i;
        return this.comps[i];
    }
    /**
     * Retrieve i-th component.
     * @throws i-th component does not exist.
     */
    at(i) {
        const comp = this.get(i);
        if (!comp) {
            throw new Error(`component ${i} out of range`);
        }
        return comp;
    }
    /** Get URI string. */
    toString() {
        this.uri_ ??= `/${this.comps.map((comp) => comp.toString()).join("/")}`;
        return this.uri_;
    }
    /** Get sub name [begin, end). */
    slice(begin, end) {
        return new Name(this.comps.slice(begin, end));
    }
    /** Get prefix of n components. */
    getPrefix(n) {
        return this.slice(0, n);
    }
    append(...args) {
        if (args.length === 2 &&
            typeof args[0].create === "function") {
            return this.append(args[0].create(args[1]));
        }
        const suffix = args;
        return new Name([...this.comps, ...suffix]);
    }
    /** Return a copy of Name with a component replaced. */
    replaceAt(i, comp) {
        const comps = [...this.comps];
        comps.splice(i, 1, comp);
        return new Name(comps);
    }
    /** Compare with other name. */
    compare(other) {
        other = Name.from(other);
        const commonSize = Math.min(this.length, other.length);
        const cmp = this.comparePrefix(other, commonSize);
        if (cmp !== Name.CompareResult.EQUAL) {
            return cmp;
        }
        if (this.length > commonSize) {
            return Name.CompareResult.RPREFIX;
        }
        if (other.length > commonSize) {
            return Name.CompareResult.LPREFIX;
        }
        return Name.CompareResult.EQUAL;
    }
    /** Determine if this name equals other. */
    equals(other) {
        other = Name.from(other);
        if (this.hex_ !== undefined && other.hex_ !== undefined) {
            return this.hex_ === other.hex_;
        }
        return this.length === other.length && this.comparePrefix(other, this.length) === Name.CompareResult.EQUAL;
    }
    /** Determine if this name is a prefix of other. */
    isPrefixOf(other) {
        other = Name.from(other);
        return this.length <= other.length && this.comparePrefix(other, this.length) === Name.CompareResult.EQUAL;
    }
    comparePrefix(other, n) {
        for (let i = 0; i < n; ++i) {
            const cmp = this.comps[i].compare(other.comps[i]);
            if (cmp !== Component.CompareResult.EQUAL) {
                return cmp;
            }
        }
        return Name.CompareResult.EQUAL;
    }
    encodeTo(encoder) {
        if (this.value_) {
            encoder.prependTlv(TT.Name, this.value_);
        }
        else {
            encoder.prependTlv(TT.Name, ...this.comps);
        }
    }
}
(function (Name) {
    function isNameLike(obj) {
        return obj instanceof Name || typeof obj === "string";
    }
    Name.isNameLike = isNameLike;
    function from(input) {
        return input instanceof Name ? input : new Name(input);
    }
    Name.from = from;
    /** Name compare result. */
    let CompareResult;
    (function (CompareResult) {
        /** lhs is less than, but not a prefix of rhs */
        CompareResult[CompareResult["LT"] = -2] = "LT";
        /** lhs is a prefix of rhs */
        CompareResult[CompareResult["LPREFIX"] = -1] = "LPREFIX";
        /** lhs and rhs are equal */
        CompareResult[CompareResult["EQUAL"] = 0] = "EQUAL";
        /** rhs is a prefix of lhs */
        CompareResult[CompareResult["RPREFIX"] = 1] = "RPREFIX";
        /** rhs is less than, but not a prefix of lhs */
        CompareResult[CompareResult["GT"] = 2] = "GT";
    })(CompareResult = Name.CompareResult || (Name.CompareResult = {}));
})(Name || (Name = {}));
