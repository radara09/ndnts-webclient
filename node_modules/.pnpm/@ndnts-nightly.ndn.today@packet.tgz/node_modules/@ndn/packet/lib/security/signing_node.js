import { sha256, timingSafeEqual } from "@ndn/util";
import { SigType } from "../an_node.js";
import { KeyLocator } from "../key-locator_node.js";
import { SigInfo } from "../sig-info_node.js";
export var LLSign;
(function (LLSign) {
    LLSign.OP = Symbol("LLSign.OP");
})(LLSign || (LLSign = {}));
export var LLVerify;
(function (LLVerify) {
    LLVerify.OP = Symbol("LLVerify.OP");
})(LLVerify || (LLVerify = {}));
export var Signer;
(function (Signer) {
    /**
     * Put SigInfo on packet if it does not exist.
     * @param pkt target packet.
     * @param sigType optionally set sigType.
     * @param keyLocator optionally set keyLocator; false to delete KeyLocator.
     */
    function putSigInfo(pkt, sigType, keyLocator) {
        pkt.sigInfo ??= new SigInfo();
        if (sigType !== undefined) {
            pkt.sigInfo.type = sigType;
        }
        if (keyLocator === false) {
            pkt.sigInfo.keyLocator = undefined;
        }
        else if (keyLocator !== undefined) {
            pkt.sigInfo.keyLocator = new KeyLocator(keyLocator);
        }
        return pkt.sigInfo;
    }
    Signer.putSigInfo = putSigInfo;
})(Signer || (Signer = {}));
export var Verifier;
(function (Verifier) {
    /** Throw if packet does not have expected SigType. */
    function checkSigType(pkt, expectedSigType) {
        if (pkt.sigInfo?.type !== expectedSigType) {
            throw new Error(`packet does not have SigType ${expectedSigType}`);
        }
    }
    Verifier.checkSigType = checkSigType;
    /** Throw bad signature error if not OK. */
    function throwOnBadSig(ok) {
        if (!ok) {
            throw new Error("bad signature value");
        }
    }
    Verifier.throwOnBadSig = throwOnBadSig;
})(Verifier || (Verifier = {}));
/** Signer and Verifier that do nothing. */
export const noopSigning = {
    sign() {
        return Promise.resolve();
    },
    verify() {
        return Promise.resolve();
    },
};
/** Signer and Verifier for SigType.Sha256 digest. */
export const digestSigning = {
    sign(pkt) {
        Signer.putSigInfo(pkt, SigType.Sha256, false);
        return pkt[LLSign.OP]((input) => sha256(input));
    },
    async verify(pkt) {
        Verifier.checkSigType(pkt, SigType.Sha256);
        return pkt[LLVerify.OP](async (input, sig) => {
            const h = await sha256(input);
            const ok = timingSafeEqual(sig, h);
            Verifier.throwOnBadSig(ok);
        });
    },
};
/**
 * Signer for SigType.Null, a packet that is not signed.
 * @see https://redmine.named-data.net/projects/ndn-tlv/wiki/NullSignature
 */
export const nullSigner = {
    sign(pkt) {
        Signer.putSigInfo(pkt, SigType.Null, false);
        pkt.sigValue = new Uint8Array();
        return Promise.resolve();
    },
};
