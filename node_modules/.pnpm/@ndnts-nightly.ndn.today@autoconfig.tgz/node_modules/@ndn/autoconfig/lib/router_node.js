import { Endpoint } from "@ndn/endpoint";
import { TapFace } from "@ndn/fw";
import { Interest, Name } from "@ndn/packet";
import hirestime from "hirestime";
import { createFace } from "./platform_node.js";
const now = hirestime();
/** Connect to a router and test the connection. */
export async function connectToRouter(router, opts = {}) {
    const face = await createFace(router, opts);
    const testConnectionStart = now();
    let testConnectionDuration;
    let testConnectionResult;
    try {
        testConnectionResult = await testConnection(face, opts);
        testConnectionDuration = now() - testConnectionStart;
    }
    catch (err) {
        face.close();
        throw err;
    }
    return { router, face, testConnectionDuration, testConnectionResult };
}
async function testConnection(face, { testConnection: tc = new Name("/localhop/nfd/rib/list"), testConnectionTimeout = 2000, }) {
    if (tc === false) {
        return undefined;
    }
    if (typeof tc === "function") {
        return tc(face);
    }
    if (!Array.isArray(tc)) {
        tc = [tc];
    }
    const tapFace = TapFace.create(face);
    tapFace.addRoute("/");
    const abort = new AbortController();
    try {
        const endpoint = new Endpoint({ fw: tapFace.fw, signal: abort.signal });
        await Promise.any(tc.map((pkt) => {
            if (typeof pkt === "string" && pkt.endsWith("/*")) {
                pkt = new Name(pkt.slice(0, -2)).append(Math.trunc(Math.random() * 1e8).toString().padStart(8, "0"));
            }
            const interest = pkt instanceof Interest ? pkt :
                new Interest(pkt, Interest.CanBePrefix, Interest.Lifetime(testConnectionTimeout));
            return endpoint.consume(interest);
        }));
    }
    finally {
        abort.abort();
        tapFace.close();
    }
    return undefined;
}
