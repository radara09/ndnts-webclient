import { Name } from "@ndn/packet";
import { FCH_DEFAULTS, fetch } from "./platform_browser.js";
/** FCH service query. */
export async function fchQuery(req = {}) {
    const { server = "https://fch.ndn.today", ipv4 = FCH_DEFAULTS.hasIPv4, ipv6 = FCH_DEFAULTS.hasIPv6, position, network, signal, } = req;
    const hQuery = async (tcs, accept) => {
        const uri = new URL(server);
        const search = uri.searchParams;
        for (const [transport, count] of tcs) {
            search.append("cap", transport);
            search.append("k", `${count}`);
        }
        if (ipv4 !== undefined) {
            search.set("ipv4", `${Number(ipv4)}`);
        }
        if (ipv6 !== undefined) {
            search.set("ipv6", `${Number(ipv6)}`);
        }
        if (position?.length === 2) {
            const [lon, lat] = position;
            search.set("lon", `${lon.toFixed(5)}`);
            search.set("lat", `${lat.toFixed(5)}`);
        }
        if (network) {
            search.set("network", network);
        }
        const hRes = await fetch(uri.toString(), { headers: { accept }, signal });
        if (!hRes.ok) {
            throw new Error(`HTTP ${hRes.status}`);
        }
        return hRes;
    };
    const tcs = parseTransportCounts(req);
    const res = new FchResp();
    try {
        const hRes = await hQuery(tcs, "application/json, text/plain, */*");
        if (hRes.headers.get("Content-Type")?.startsWith("application/json")) {
            await res.setJsonResponse(hRes);
            return res;
        }
        if (tcs.length === 1) {
            await res.addTextResponse(tcs[0][0], hRes);
            return res;
        }
    }
    catch { }
    await Promise.all(tcs.map(async (tc) => {
        try {
            const hRes = await hQuery([tc], "text/plain, */*");
            await res.addTextResponse(tc[0], hRes);
        }
        catch { }
    }));
    return res;
}
function parseTransportCounts({ transport, count = 1, transports, }) {
    if (transports === undefined) {
        if (transport) {
            return [[transport, count]];
        }
        transports = FCH_DEFAULTS.transports();
    }
    if (Array.isArray(transports)) {
        return transports
            .map((transport) => [transport, count]);
    }
    return Object.entries(transports);
}
class FchResp {
    updated;
    routers = [];
    async setJsonResponse(hRes) {
        const body = await hRes.json();
        this.updated = new Date(body.updated);
        this.routers = Array.from(body.routers, (r) => ({
            transport: String(r.transport),
            connect: String(r.connect),
            prefix: r.prefix ? new Name(r.prefix) : undefined,
        }));
    }
    async addTextResponse(transport, hRes) {
        const body = (await hRes.text()).trim();
        if (body === "") {
            return;
        }
        for (const connect of body.split(",")) {
            this.routers.push({
                transport,
                connect,
            });
        }
    }
}
