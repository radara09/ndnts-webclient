import { __importDefault, __importStar } from "tslib";
import { L3Face, rxFromPacketIterable, Transport } from "@ndn/l3face";
import _cjsDefaultImport0 from "event-iterator"; const EventIterator = __importDefault(_cjsDefaultImport0).default;
import { makeWebSocket } from "./ws_browser.js";
/** WebSocket transport. */
export class WsTransport extends Transport {
    sock;
    opts;
    rx;
    highWaterMark;
    lowWaterMark;
    constructor(sock, opts) {
        super({ describe: `WebSocket(${sock.url})` });
        this.sock = sock;
        this.opts = opts;
        sock.binaryType = "arraybuffer";
        this.rx = rxFromPacketIterable(new EventIterator(({ push, stop }) => {
            const handleMessage = (evt) => {
                push(new Uint8Array(evt instanceof ArrayBuffer ? evt : evt.data));
            };
            sock.addEventListener("message", handleMessage);
            sock.addEventListener("close", stop);
            return () => {
                sock.removeEventListener("message", handleMessage);
                sock.removeEventListener("close", stop);
            };
        }));
        this.highWaterMark = opts.highWaterMark ?? 1024 * 1024;
        this.lowWaterMark = opts.lowWaterMark ?? 16 * 1024;
    }
    close() {
        this.sock.close();
    }
    get mtu() { return Infinity; }
    tx = async (iterable) => {
        try {
            for await (const pkt of iterable) {
                if (this.sock.readyState !== this.sock.OPEN) {
                    throw new Error(`unexpected WebSocket.readyState ${this.sock.readyState}`);
                }
                this.sock.send(pkt);
                if (this.sock.bufferedAmount > this.highWaterMark) {
                    await this.waitForTxBuffer();
                }
            }
        }
        finally {
            this.close();
        }
    };
    waitForTxBuffer() {
        return new Promise((resolve) => {
            const timer = setInterval(() => {
                if (this.sock.bufferedAmount <= this.lowWaterMark || this.sock.readyState !== this.sock.OPEN) {
                    clearInterval(timer);
                    resolve();
                }
            }, 100);
        });
    }
    reopen() {
        return WsTransport.connect(this.sock.url, this.opts);
    }
}
(function (WsTransport) {
    /**
     * Create a transport and connect to remote endpoint.
     * @param uri server URI or WebSocket object.
     * @param opts other options.
     */
    function connect(uri, opts = {}) {
        const { connectTimeout = 10000, signal, } = opts;
        return new Promise((resolve, reject) => {
            const sock = typeof uri === "string" ? makeWebSocket(uri) : uri;
            if (sock.readyState === sock.OPEN) {
                resolve(new WsTransport(sock, opts));
                return;
            }
            let timeout; // eslint-disable-line prefer-const
            const fail = (err) => {
                clearTimeout(timeout);
                sock.close();
                reject(err);
            };
            timeout = setTimeout(() => fail(new Error("connectTimeout")), connectTimeout);
            const onabort = () => fail(new Error("abort"));
            signal?.addEventListener("abort", onabort);
            const onerror = (evt) => {
                sock.close();
                reject(new Error(evt.message));
            };
            sock.addEventListener("error", onerror);
            sock.addEventListener("open", () => {
                clearTimeout(timeout);
                sock.removeEventListener("error", onerror);
                signal?.removeEventListener("abort", onabort);
                resolve(new WsTransport(sock, opts));
            });
        });
    }
    WsTransport.connect = connect;
    /** Create a transport and add to forwarder. */
    WsTransport.createFace = L3Face.makeCreateFace(connect);
})(WsTransport || (WsTransport = {}));
