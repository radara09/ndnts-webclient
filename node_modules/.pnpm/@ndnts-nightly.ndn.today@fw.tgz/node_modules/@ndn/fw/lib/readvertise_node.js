import { __importDefault, __importStar } from "tslib";
import { NameMap, NameMultiMap } from "@ndn/packet";
import { pushable } from "it-pushable";
import _cjsDefaultImport0 from "retry"; const retry = __importDefault(_cjsDefaultImport0).default;
/**
 * Manage advertised prefix of the forwarder.
 *
 * This class keeps track of what prefixes are announced by the owning forwarder.
 * It accepts announcements from faces attached to the forwarder, and then informs
 * each destination on what prefixes should be advertised.
 */
export class Readvertise {
    fw;
    constructor(fw) {
        this.fw = fw;
    }
    announcements = new NameMultiMap();
    destinations = new Set();
    addAnnouncement(face, name) {
        if (this.announcements.add(name, face) > 1) {
            return;
        }
        this.fw.emit("annadd", name);
        for (const dest of this.destinations) {
            dest.advertise(name);
        }
    }
    removeAnnouncement(face, name) {
        if (this.announcements.remove(name, face) > 0) {
            return;
        }
        this.fw.emit("annrm", name);
        for (const dest of this.destinations) {
            dest.withdraw(name);
        }
    }
    /**
     * Cancel timers and other I/O resources.
     * This instance should not be used after this operation.
     */
    close() {
        for (const dest of this.destinations) {
            dest.disable();
        }
    }
}
/**
 * A destination of prefix advertisement.
 *
 * Generally, a prefix advertised to a destination would cause Interests matching the prefix
 * to come to the forwarder, aka prefix registration.
 */
export class ReadvertiseDestination {
    retryOptions;
    readvertise;
    table = new NameMap();
    queue = pushable({ objectMode: true });
    closed = false;
    constructor(retryOptions = {
        forever: true,
        minTimeout: 5000,
        maxTimeout: 60000,
        randomize: true,
    }) {
        this.retryOptions = retryOptions;
    }
    /** Enable and attach to a forwarder. */
    enable(fw) {
        this.readvertise = fw.readvertise;
        this.readvertise.destinations.add(this);
        for (const [name] of this.readvertise.announcements.associations()) {
            this.queue.push(name);
        }
        void this.process();
    }
    /**
     * Disable and detach from forwarder.
     *
     * Once detached, this instance is no longer usable.
     */
    disable() {
        this.readvertise?.destinations.delete(this);
        this.readvertise = undefined;
        for (const [name, record] of this.table) {
            this.queue.push(name);
            record.status = ReadvertiseDestination.Status.WITHDRAWING;
        }
        this.queue.end();
        this.closed = true;
    }
    /** Set a prefix to be advertised. */
    advertise(name) {
        let record = this.table.get(name);
        if (!record) {
            record = {
                status: ReadvertiseDestination.Status.ADVERTISING,
                state: this.makeState(name),
            };
            this.table.set(name, record);
        }
        record.status = ReadvertiseDestination.Status.ADVERTISING;
        this.restart(name, record);
    }
    /** Set a prefix to be withdrawn. */
    withdraw(name) {
        const record = this.table.get(name);
        if (!record) {
            return;
        }
        record.status = ReadvertiseDestination.Status.WITHDRAWING;
        this.restart(name, record);
    }
    restart(name, record) {
        record.retry?.stop();
        record.retry = retry.operation(this.retryOptions);
        record.retry.attempt(() => {
            if (this.closed) {
                record.retry.stop();
            }
            else {
                this.queue.push(name);
            }
        });
    }
    async process() {
        for await (const name of this.queue) {
            const record = this.table.get(name);
            if (!record) {
                continue;
            }
            const { status, retry, state } = record;
            switch (status) {
                case ReadvertiseDestination.Status.ADVERTISING: {
                    try {
                        await this.doAdvertise(name, state);
                        if (record.status === ReadvertiseDestination.Status.ADVERTISING) {
                            record.status = ReadvertiseDestination.Status.ADVERTISED;
                            retry.stop();
                        }
                    }
                    catch (err) {
                        retry.retry(err);
                    }
                    break;
                }
                case ReadvertiseDestination.Status.WITHDRAWING: {
                    try {
                        await this.doWithdraw(name, state);
                        if (record.status === ReadvertiseDestination.Status.WITHDRAWING) {
                            record.status = ReadvertiseDestination.Status.WITHDRAWN;
                            retry.stop();
                            this.table.delete(name);
                        }
                    }
                    catch (err) {
                        retry.retry(err);
                    }
                    break;
                }
            }
        }
    }
    /** Create per-prefix state. */
    makeState(name) {
        void name;
        return {};
    }
}
(function (ReadvertiseDestination) {
    let Status;
    (function (Status) {
        Status[Status["ADVERTISING"] = 0] = "ADVERTISING";
        Status[Status["ADVERTISED"] = 1] = "ADVERTISED";
        Status[Status["WITHDRAWING"] = 2] = "WITHDRAWING";
        Status[Status["WITHDRAWN"] = 3] = "WITHDRAWN";
    })(Status = ReadvertiseDestination.Status || (ReadvertiseDestination.Status = {}));
})(ReadvertiseDestination || (ReadvertiseDestination = {}));
