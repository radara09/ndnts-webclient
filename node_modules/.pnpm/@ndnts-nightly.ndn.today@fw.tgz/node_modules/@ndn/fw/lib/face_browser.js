import { EventEmitter } from "events";
import { Data, Interest, Nack, Name, NameMultiSet } from "@ndn/packet";
import { safeIter } from "@ndn/util";
import { pushable } from "it-pushable";
import { filter, pipeline, tap } from "streaming-iterables";
function duplexFromRxTx(rxtx) {
    return (iterable) => {
        const rxtxD = rxtx;
        if (typeof rxtxD.duplex === "function") {
            return rxtxD.duplex(iterable);
        }
        const rxtxS = rxtx;
        rxtxS.tx(iterable);
        return rxtxS.rx;
    };
}
function computeAnnouncement(name, announcement) {
    switch (typeof announcement) {
        case "number": {
            return name.getPrefix(announcement);
        }
        case "boolean": {
            return announcement ? name : undefined;
        }
    }
    return Name.from(announcement);
}
export class FaceImpl extends EventEmitter {
    fw;
    rxtx;
    attributes;
    routes = new NameMultiSet();
    announcements = new NameMultiSet();
    running = true;
    txQueue = pushable({ objectMode: true });
    constructor(fw, rxtx, attributes) {
        super();
        this.fw = fw;
        this.rxtx = rxtx;
        this.attributes = {
            local: false,
            advertiseFrom: true,
            routeCapture: true,
            ...rxtx.attributes,
            ...attributes,
        };
        fw.emit("faceadd", this);
        fw.faces.add(this);
        void pipeline(() => this.txLoop(), tap((pkt) => fw.emit("pkttx", this, pkt)), duplexFromRxTx(rxtx), tap((pkt) => fw.emit("pktrx", this, pkt)), this.rxLoop);
        rxtx.on?.("up", this.handleLowerUp);
        rxtx.on?.("down", this.handleLowerDown);
    }
    close() {
        if (!this.running) {
            return;
        }
        this.running = false;
        this.rxtx.off?.("up", this.handleLowerUp);
        this.rxtx.off?.("down", this.handleLowerDown);
        this.fw.faces.delete(this);
        for (const [name] of this.routes.multiplicities()) {
            this.fw.fib.delete(this, name.valueHex);
        }
        for (const [name] of this.announcements.multiplicities()) {
            this.fw.readvertise.removeAnnouncement(this, name);
        }
        this.txQueue.end(new Error("close"));
        this.emit("close");
        this.fw.emit("facerm", this);
    }
    toString() {
        return this.attributes.describe ?? "FwFace";
    }
    hasRoute(nameInput) {
        const name = Name.from(nameInput);
        return this.routes.count(name) > 0;
    }
    addRoute(nameInput, announcement = true) {
        const name = Name.from(nameInput);
        this.fw.emit("prefixadd", this, name);
        if (this.routes.add(name) === 1) {
            this.fw.fib.insert(this, name.valueHex, this.attributes.routeCapture);
        }
        const ann = computeAnnouncement(name, announcement);
        if (ann) {
            this.addAnnouncement(ann);
        }
    }
    removeRoute(nameInput, announcement = true) {
        const name = Name.from(nameInput);
        const ann = computeAnnouncement(name, announcement);
        if (ann) {
            this.removeAnnouncement(ann);
        }
        if (this.routes.remove(name) === 0) {
            this.fw.fib.delete(this, name.valueHex);
        }
        this.fw.emit("prefixrm", this, name);
    }
    addAnnouncement(nameInput) {
        if (!this.attributes.advertiseFrom) {
            return;
        }
        const name = Name.from(nameInput);
        if (this.announcements.add(name) === 1) {
            this.fw.readvertise.addAnnouncement(this, name);
        }
    }
    removeAnnouncement(nameInput) {
        if (!this.attributes.advertiseFrom) {
            return;
        }
        const name = Name.from(nameInput);
        if (this.announcements.remove(name) === 0) {
            this.fw.readvertise.removeAnnouncement(this, name);
        }
    }
    /** Transmit a packet on the face. */
    send(pkt) {
        if (!this.running) {
            return;
        }
        this.txQueue.push(pkt);
    }
    handleLowerUp = () => {
        this.emit("up");
    };
    handleLowerDown = () => {
        this.emit("down");
    };
    rxLoop = async (input) => {
        for await (const pkt of filter(() => this.running, input)) {
            switch (true) {
                case pkt.l3 instanceof Interest: {
                    this.fw[pkt.cancel ? "cancelInterest" : "processInterest"](this, pkt);
                    break;
                }
                case pkt.l3 instanceof Data: {
                    this.fw.processData(this, pkt);
                    break;
                }
                case pkt.l3 instanceof Nack: {
                    this.fw.processNack(this, pkt);
                    break;
                }
            }
        }
        this.close();
    };
    txLoop() {
        return safeIter(this.txQueue);
    }
}
