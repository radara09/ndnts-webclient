import { __importDefault, __importStar } from "tslib";
import { Interest } from "@ndn/packet";
import hirestime from "hirestime";
import _cjsDefaultImport0 from "mnemonist/default-map.js"; const DefaultMap = __importDefault(_cjsDefaultImport0).default;
import { filter, flatMap, pipeline, reduce, tap } from "streaming-iterables";
import { FwPacket, RejectInterest } from "./packet_node.js";
const getNow = hirestime();
/** Aggregated pending Interests from one or more downstream faces. */
export class PitEntry {
    pit;
    key;
    /** Representative Interest. */
    interest;
    /** Outgoing numeric PIT token. */
    token;
    /** Downstream records. */
    dnRecords = new DefaultMap(() => ({ nRx: 0, expire: 0, nonce: 0, token: undefined }));
    /** Last expiration time among downstream. */
    lastExpire = 0;
    /** Entry expiration timer; should match this.lastExpire. */
    expireTimer;
    constructor(pit, key, interest) {
        this.pit = pit;
        this.key = key;
        this.interest = new Interest(interest);
    }
    /** Record Interest from downstream. */
    receiveInterest(face, { l3: interest, token }) {
        const now = getNow();
        const expire = now + interest.lifetime;
        const nonce = interest.nonce ?? Interest.generateNonce();
        const dnR = this.dnRecords.get(face);
        ++dnR.nRx;
        dnR.expire = expire;
        dnR.nonce = nonce;
        dnR.token = token;
        this.updateExpire(now);
    }
    /** Record Interest cancellation from downstream. */
    cancelInterest(face) {
        const dnR = this.dnRecords.peek(face);
        if (!dnR) {
            return;
        }
        this.dnRecords.delete(face);
        this.updateExpire();
        face.send(new RejectInterest("cancel", this.interest, dnR.token));
    }
    /** Forward Interest to upstream. */
    forwardInterest(face) {
        const lifetime = this.lastExpire - getNow();
        if (lifetime <= 0) {
            return;
        }
        this.interest.lifetime = lifetime;
        face.send(FwPacket.create(this.interest, this.token));
    }
    /** Determine which downstream faces should receive Data from upstream. */
    *returnData(up) {
        clearTimeout(this.expireTimer);
        this.pit.eraseEntry(this);
        const now = getNow();
        for (const [dn, { expire, token }] of this.dnRecords) {
            if (expire > now && dn !== up) {
                yield { dn, token };
            }
        }
    }
    updateExpire(now = getNow()) {
        let lastExpire = 0;
        for (const { expire } of this.dnRecords.values()) {
            lastExpire = Math.max(lastExpire, expire);
        }
        if (lastExpire <= now) {
            lastExpire = 0;
        }
        if (this.lastExpire === lastExpire) {
            return;
        }
        this.lastExpire = lastExpire;
        clearTimeout(this.expireTimer);
        if (this.lastExpire === 0) {
            this.expire();
        }
        else {
            this.pit.insertEntry(this);
            this.expireTimer = setTimeout(this.expire, this.lastExpire - now);
        }
    }
    expire = () => {
        this.pit.eraseEntry(this);
        for (const [face, { token }] of this.dnRecords) {
            face.send(new RejectInterest("expire", this.interest, token));
        }
    };
}
/** Pending Interest table. */
export class Pit {
    dataNoTokenMatch;
    constructor(dataNoTokenMatch) {
        this.dataNoTokenMatch = dataNoTokenMatch;
    }
    byName = new Map();
    byToken = new Map();
    lastToken = 0;
    generateToken() {
        do {
            --this.lastToken;
            if (this.lastToken <= 0) {
                this.lastToken = 0xFFFFFFFF;
            }
        } while (this.byToken.has(this.lastToken));
        return this.lastToken;
    }
    insertEntry(entry) {
        this.byName.set(entry.key, entry);
        entry.token ??= this.generateToken();
        this.byToken.set(entry.token, entry);
    }
    eraseEntry(entry) {
        this.byName.delete(entry.key);
        this.byToken.delete(entry.token);
    }
    /**
     * Cancel timers and other I/O resources.
     * This instance should not be used after this operation.
     */
    close() {
        for (const entry of this.byName.values()) {
            clearTimeout(entry.expireTimer);
        }
    }
    lookup({ l3: interest }, canInsert = true) {
        const key = `${interest.name.valueHex} ${interest.canBePrefix ? "+" : "-"}${interest.mustBeFresh ? "+" : "-"}`;
        let entry = this.byName.get(key);
        if (!entry && canInsert) {
            entry = new PitEntry(this, key, interest);
        }
        return entry;
    }
    /**
     * Satisfy pending Interests with incoming Data.
     * @returns true if Data satisfies any pending Interest; false if Data is unsolicited.
     */
    async satisfy(face, { l3: data, token }) {
        const nSentData = await pipeline(() => this.findPotentialMatches(data, token), filter(({ interest }) => data.canSatisfy(interest)), flatMap((entry) => entry.returnData(face)), tap(({ dn, token: dnToken }) => dn.send(FwPacket.create(data, dnToken))), reduce((count) => count + 1, 0));
        return nSentData > 0;
    }
    *findPotentialMatches(data, token) {
        if (typeof token === "number") {
            const entry = this.byToken.get(token);
            if (entry) {
                yield entry;
            }
            return;
        }
        if (!this.dataNoTokenMatch) {
            return;
        }
        let keySuffixes = [" ++", " +-", " -+", " --"];
        for (let prefix = data.name; prefix.length > 0; prefix = prefix.getPrefix(-1)) {
            const prefixHex = prefix.valueHex;
            for (const keySuffix of keySuffixes) {
                const entry = this.byName.get(prefixHex + keySuffix);
                if (entry) {
                    yield entry;
                }
            }
            keySuffixes = [" ++", " +-"];
        }
    }
}
