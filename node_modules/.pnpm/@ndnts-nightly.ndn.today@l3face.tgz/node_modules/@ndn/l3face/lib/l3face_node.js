import { __importDefault, __importStar } from "tslib";
import { EventEmitter } from "node:events";
import { Forwarder, FwPacket } from "@ndn/fw";
import { LpService } from "@ndn/lp";
import { Interest } from "@ndn/packet";
import { asDataView } from "@ndn/util";
import { abortableSource, AbortError as IteratorAbortError } from "abortable-iterator";
import { pushable } from "it-pushable";
import _cjsDefaultImport0 from "retry"; const retry = __importDefault(_cjsDefaultImport0).default;
import { consume, filter, map, pipeline } from "streaming-iterables";
import { Transport } from "./transport_node.js";
/** Network layer face for sending and receiving L3 packets. */
export class L3Face extends EventEmitter {
    transport;
    attributes;
    lp;
    rx;
    wireTokenPrefix = Math.trunc(Math.random() * 0x10000);
    get state() { return this.state_; }
    set state(newState) {
        if (newState === this.state_) {
            return;
        }
        this.state_ = newState;
        this.emit("state", newState);
        switch (newState) {
            case L3Face.State.UP: {
                this.emit("up");
                break;
            }
            case L3Face.State.DOWN: {
                const err = this.lastError instanceof Error ?
                    this.lastError :
                    new Error(`${this.lastError ?? "unknown error"}`);
                this.emit("down", err);
                this.lastError = undefined;
                break;
            }
            case L3Face.State.CLOSED: {
                this.emit("close");
                break;
            }
        }
    }
    state_ = L3Face.State.UP;
    lastError;
    rxSources = pushable({ objectMode: true });
    reopenRetry;
    constructor(transport, attributes = {}, lpOptions = {}) {
        super();
        this.transport = transport;
        this.attributes = {
            describe: `L3Face(${transport})`,
            advertiseFrom: false,
            ...transport.attributes,
            ...attributes,
        };
        this.lp = new LpService(lpOptions, transport);
        this.rx = this.makeRx();
    }
    async *makeRx() {
        for await (const source of this.rxSources) {
            try {
                yield* this.rxTransform(source);
                this.lastError = new Error("RX ending");
                this.state = L3Face.State.DOWN;
            }
            catch (err) {
                if (!(err instanceof IteratorAbortError)) {
                    this.lastError = err;
                    this.state = L3Face.State.DOWN;
                }
            }
        }
    }
    async *rxTransform(transportRx) {
        yield* pipeline(() => transportRx, this.lp.rx, filter((pkt) => {
            if (pkt instanceof LpService.RxError) {
                this.emit("rxerror", pkt);
                return false;
            }
            return true;
        }), map(({ l3, token: wireToken }) => {
            let internalToken;
            if (l3 instanceof Interest) {
                internalToken = wireToken;
            }
            else if (wireToken?.length === 6) {
                const dv = asDataView(wireToken);
                if (dv.getUint16(0) === this.wireTokenPrefix) {
                    internalToken = dv.getUint32(2);
                }
            }
            return FwPacket.create(l3, internalToken);
        }));
    }
    txTransform(fwTx) {
        return pipeline(() => fwTx, filter((pkt) => FwPacket.isEncodable(pkt)), map(({ l3, token: internalToken }) => {
            let wireToken;
            if (typeof internalToken === "number") {
                wireToken = new Uint8Array(6);
                const dv = asDataView(wireToken);
                dv.setUint16(0, this.wireTokenPrefix);
                dv.setUint32(2, internalToken);
            }
            else if (internalToken instanceof Uint8Array) {
                wireToken = internalToken;
            }
            return { l3, token: wireToken };
        }), this.lp.tx, filter((value) => {
            if (value instanceof LpService.TxError) {
                this.emit("txerror", value);
                return false;
            }
            return true;
        }));
    }
    tx = async (iterable) => {
        const txSourceIterator = this.txTransform(iterable)[Symbol.asyncIterator]();
        const txSourceIterable = {
            [Symbol.asyncIterator]: () => ({
                next: () => txSourceIterator.next(),
            }),
        };
        while (this.state !== L3Face.State.CLOSED) {
            if (this.state === L3Face.State.DOWN) {
                this.reopenTransport();
            }
            const abort = new AbortController();
            const handleStateChange = () => abort.abort();
            this.once("state", handleStateChange);
            try {
                const txSource = abortableSource(txSourceIterable, abort.signal);
                if (this.state === L3Face.State.UP) {
                    this.rxSources.push(abortableSource(this.transport.rx, abort.signal));
                    await this.transport.tx(txSource);
                }
                else {
                    await consume(txSource);
                }
                this.state = L3Face.State.CLOSED;
            }
            catch (err) {
                if (!(err instanceof IteratorAbortError)) {
                    this.lastError = err;
                    this.state = L3Face.State.DOWN;
                }
            }
            finally {
                abort.abort();
                this.off("state", handleStateChange);
            }
        }
        this.reopenRetry?.stop();
        this.rxSources.end();
    };
    reopenTransport() {
        this.reopenRetry?.stop();
        this.reopenRetry = retry.operation({
            forever: true,
            minTimeout: 100,
            maxTimeout: 60000,
            randomize: true,
        });
        this.reopenRetry.attempt(async () => {
            try {
                this.transport = await this.transport.reopen();
            }
            catch (err) {
                if (!(err instanceof Transport.ReopenNotSupportedError)) {
                    this.reopenRetry.retry(err);
                }
                return;
            }
            if (this.state === L3Face.State.CLOSED) {
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                void this.transport.tx((async function* () { })()); // shutdown transport
                return;
            }
            this.reopenRetry.stop();
            this.state = L3Face.State.UP;
        });
    }
}
(function (L3Face) {
    let State;
    (function (State) {
        State[State["UP"] = 0] = "UP";
        State[State["DOWN"] = 1] = "DOWN";
        State[State["CLOSED"] = 2] = "CLOSED";
    })(State = L3Face.State || (L3Face.State = {}));
    function makeCreateFace(createTransport) {
        return (async (opts, ...args) => {
            const created = await createTransport(...args);
            const { fw = Forwarder.getDefault(), addRoutes, l3, lp, callback, } = opts;
            const makeFace = (transport) => {
                const l3face = new L3Face(transport, { advertiseFrom: false, ...l3 }, lp);
                const fwFace = fw.addFace(l3face);
                processAddRoutes(fwFace, addRoutes);
                callback?.(transport, l3face, fwFace);
                return fwFace;
            };
            return Array.isArray(created) ? created.map(makeFace) : makeFace(created);
        });
    }
    L3Face.makeCreateFace = makeCreateFace;
    function processAddRoutes(fwFace, addRoutes = ["/"]) {
        for (const routeName of addRoutes) {
            fwFace.addRoute(routeName);
        }
    }
    L3Face.processAddRoutes = processAddRoutes;
})(L3Face || (L3Face = {}));
