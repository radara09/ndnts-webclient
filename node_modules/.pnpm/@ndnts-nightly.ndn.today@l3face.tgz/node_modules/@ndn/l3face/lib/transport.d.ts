import type { Decoder } from "@ndn/tlv";
/**
 * Low-level transport.
 *
 * The transport understands NDN TLV structures, but does not otherwise concern with packet format.
 */
export declare abstract class Transport {
    readonly attributes: Transport.Attributes;
    abstract readonly rx: Transport.Rx;
    abstract readonly tx: Transport.Tx;
    protected constructor(attributes: Transport.Attributes);
    /**
     * Return the transport MTU, if known.
     * The transport should be able to send TLV structure of up to this size.
     */
    get mtu(): number;
    /**
     * Reopen the transport after it has failed.
     * @returns the same transport or a new transport after it has been reconnected.
     */
    reopen(): Promise<Transport>;
    toString(): string;
}
export declare namespace Transport {
    interface Attributes extends Record<string, any> {
        /**
         * Textual description.
         * Default is automatically generated from constructor name.
         */
        describe?: string;
        /**
         * Whether the transport connects to a destination on the local machine.
         * Default is false.
         */
        local?: boolean;
        /**
         * Whether the transport can possibly talk to multiple peers.
         * Default is false;
         */
        multicast?: boolean;
    }
    /** RX iterable for incoming packets. */
    type Rx = AsyncIterable<Decoder.Tlv>;
    /**
     * TX function for outgoing packets.
     * @returns Promise that resolves when iterable is exhausted, and rejects upon error.
     */
    type Tx = (iterable: AsyncIterable<Uint8Array>) => Promise<void>;
    /**
     * Error thrown by transport.reopen() to indicate that reopen operation is not supported.
     * No further reopen() will be attempted.
     */
    class ReopenNotSupportedError extends Error {
        constructor();
    }
}
