import { type FwFace, Forwarder, FwPacket } from "@ndn/fw";
import { LpService } from "@ndn/lp";
import { type NameLike } from "@ndn/packet";
import type TypedEmitter from "typed-emitter";
import { Transport } from "./transport.js";
type Events = {
    /** Emitted upon face state change. */
    state: (state: L3Face.State) => void;
    /** Emitted upon state becomes UP. */
    up: () => void;
    /** Emitted upon state becomes DOWN. */
    down: (err: Error) => void;
    /** Emitted upon state becomes CLOSED. */
    close: () => void;
    /** Emitted upon RX decoding error. */
    rxerror: (err: L3Face.RxError) => void;
    /** Emitted upon TX preparation error. */
    txerror: (err: L3Face.TxError) => void;
};
declare const L3Face_base: new () => TypedEmitter<Events>;
/** Network layer face for sending and receiving L3 packets. */
export declare class L3Face extends L3Face_base implements FwFace.RxTx {
    private transport;
    readonly attributes: L3Face.Attributes;
    readonly lp: LpService;
    readonly rx: AsyncIterable<FwPacket>;
    private readonly wireTokenPrefix;
    get state(): L3Face.State;
    private set state(value);
    private state_;
    private lastError?;
    private readonly rxSources;
    private reopenRetry?;
    constructor(transport: Transport, attributes?: L3Face.Attributes, lpOptions?: LpService.Options);
    private makeRx;
    private rxTransform;
    private txTransform;
    tx: (iterable: AsyncIterable<FwPacket>) => Promise<void>;
    private reopenTransport;
}
export declare namespace L3Face {
    enum State {
        UP = 0,
        DOWN = 1,
        CLOSED = 2
    }
    interface Attributes extends Transport.Attributes {
        /** Whether to readvertise registered routes. */
        advertiseFrom?: boolean;
    }
    type RxError = LpService.RxError;
    type TxError = LpService.TxError;
    /** Options to createFace function as first parameter. */
    interface CreateFaceOptions {
        /**
         * Forwarder instance to add the face to.
         * Default is the default Forwarder.
         */
        fw?: Forwarder;
        /** Routes to be added on the created face. Default is ["/"]. */
        addRoutes?: NameLike[];
        /**
         * L3Face attributes.
         * l3.advertiseFrom defaults to false in createFace function.
         */
        l3?: Attributes;
        /** NDNLP service options. */
        lp?: LpService.Options;
        /**
         * A callback to receive Transport, L3Face, and FwFace objects.
         * This can be useful for reading counters or listening to events on these objects.
         */
        callback?: (transport: Transport, l3face: L3Face, fwFace: FwFace) => void;
    }
    /**
     * A function to create a transport then add to forwarder.
     * First parameter is CreateFaceOptions.
     * Subsequent parameters are passed to Transport.connect() function.
     * Returns FwFace.
     */
    type CreateFaceFunc<R extends Transport | Transport[], P extends any[]> = (opts: CreateFaceOptions, ...args: P) => Promise<R extends Transport[] ? FwFace[] : FwFace>;
    function makeCreateFace<C extends (...args: any[]) => Promise<Transport | Transport[]>>(createTransport: C): CreateFaceFunc<C extends (...args: any[]) => Promise<infer R> ? R : never, Parameters<C>>;
    function processAddRoutes(fwFace: FwFace, addRoutes?: readonly NameLike[]): void;
}
export {};
